

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Parlos">
  <meta name="keywords" content="">
  
    <meta name="description" content="我们将从这篇笔记中学到计算机网络自上而下的结构体系，对于整体网络有清楚的认识 应用层：两大应用程序体系结构•   CS   client-server architeture  客户-服务器体系结构​    有一个总是打开的服务器主机，服务其他客户的主机的请求 ​    在进程中发起通信的进程被叫做客户，等待联系的进程被叫做服务器 ​    进程通过套接字的软件接口发送和接收报文 ​    套接字">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer Network points">
<meta property="og:url" content="https://parlosyy.github.io/2022/03/08/a/index.html">
<meta property="og:site_name" content="Yys super blog">
<meta property="og:description" content="我们将从这篇笔记中学到计算机网络自上而下的结构体系，对于整体网络有清楚的认识 应用层：两大应用程序体系结构•   CS   client-server architeture  客户-服务器体系结构​    有一个总是打开的服务器主机，服务其他客户的主机的请求 ​    在进程中发起通信的进程被叫做客户，等待联系的进程被叫做服务器 ​    进程通过套接字的软件接口发送和接收报文 ​    套接字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://parlosyy.github.io/images/7142610-8c83a040e6aebd52.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210622124727.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210622124739.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ截图20210621210001.png">
<meta property="og:image" content="https://parlosyy.github.io/images/gif.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ截图20210622173442.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ%E6%88%AA%E5%9B%BE20210622191007.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ截图20210622191741.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210622193305.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210622194810.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ截图20210622154127.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210622152430.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210622202233.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210622203926.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ截图20210622214410.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ截图20210622214530.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ截图20210622214814.png">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210623100815.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210623100823.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210623100820.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210623102329.jpg">
<meta property="og:image" content="https://parlosyy.github.io/images/QQ图片20210623102614.jpg">
<meta property="article:published_time" content="2022-03-08T06:23:59.000Z">
<meta property="article:modified_time" content="2022-03-10T00:59:49.098Z">
<meta property="article:author" content="Parlos">
<meta property="article:tag" content="cs leaning_01">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://parlosyy.github.io/images/7142610-8c83a040e6aebd52.png">
  
  
  <title>Computer Network points - Yys super blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"parlosyy.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/20210927214634_64492.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Computer Network points">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-08 14:23" pubdate>
        2022年3月8日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      110 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Computer Network points</h1>
            
            <div class="markdown-body">
              <p>我们将从这篇笔记中学到计算机网络自上而下的结构体系，对于整体网络有清楚的认识</p>
<h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a><strong>应用层：</strong></h2><h4 id="两大应用程序体系结构"><a href="#两大应用程序体系结构" class="headerlink" title="两大应用程序体系结构"></a>两大应用程序体系结构</h4><h4 id="•-CS-client-server-architeture-客户-服务器体系结构"><a href="#•-CS-client-server-architeture-客户-服务器体系结构" class="headerlink" title="•   CS   client-server architeture  客户-服务器体系结构"></a><strong>•   CS   client-server architeture  客户-服务器体系结构</strong></h4><p>​    有一个总是打开的<strong>服务器</strong>主机，服务其他<strong>客户</strong>的主机的请求</p>
<p>​    在进程中发起通信的进程被叫做客户，等待联系的进程被叫做服务器</p>
<p>​    进程通过<strong>套接字</strong>的软件接口发送和接收报文</p>
<p>​    套接字是应用程序进程和<strong>运输层协议</strong>之间的接口，也被称为应用程序和网络之间的<strong>API</strong></p>
<p>​    表示进程需要定义的两种信息：主机的<strong>IP地址</strong>，主机的<strong>端口号</strong></p>
<h4 id="•-P2P-Peer-to-peer-architecture-P2P体系结构"><a href="#•-P2P-Peer-to-peer-architecture-P2P体系结构" class="headerlink" title="•   P2P   Peer-to-peer architecture  P2P体系结构"></a><strong>•   P2P   Peer-to-peer architecture  P2P体系结构</strong></h4><p>​    应用程序在间断连接的主机对之间直接通信，这些主机被称为<strong>对等方</strong></p>
<h5 id="Bittorrent"><a href="#Bittorrent" class="headerlink" title="Bittorrent"></a>Bittorrent</h5><p>​    参与一个特定文件分发的所有对等方的集合被称为一个洪流，一个洪流中的所有对等方彼此下载等长度的块</p>
<h5 id="tit-for-tat实现"><a href="#tit-for-tat实现" class="headerlink" title="tit-for-tat实现"></a>tit-for-tat实现</h5><p>​    当前主机A将选择能够以最高速率提供数据的邻居给出优先权，当此主机随机发送时，其发送速率可能也达到某目的主机B选择的最高速率的集合中，那么目的主机B将会向A发送数据，若B发送速率也满足最高速率之一的条件，B也将成为A的优先邻居之一。以此类推，对等方能以趋向于彼此的协调的速率上载</p>
<h4 id="•-HTTP-HyperText-Transfer-Protocol-超文本传输协议"><a href="#•-HTTP-HyperText-Transfer-Protocol-超文本传输协议" class="headerlink" title="•   HTTP   HyperText Transfer Protocol 超文本传输协议"></a>•   <strong>HTTP   HyperText Transfer Protocol</strong> <strong>超文本传输协议</strong></h4><p>​    以TCP为支撑运输协议，正确快速地传输超文本文档</p>
<h5 id="持续连接与非持续连接"><a href="#持续连接与非持续连接" class="headerlink" title="持续连接与非持续连接"></a>持续连接与非持续连接</h5><p>​    HTTP既能够使用持续连接【每个请求或响应由单独的TCP发送】，也能够使用非持续连接【每个请求或响应由单独的TCP发送】</p>
<p>​    非持续连接：单次耗时——两个RTT时间（一次TCP连接和一次TCP请求）和传输文件的时间</p>
<p>​    持续连接耗时：总耗时——一个RTT（第一次TCP连接）加上n个单次耗时——一个RTT加上文件传输的时间</p>
<h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p>​    请求行：方法字段：GET、POST、HEAD、PUT、DELETE等</p>
<p>​                    URL字段：请求对象的标识</p>
<p>​                    HTTP版本字段</p>
<p>​    首部行：Host：请求的主机名</p>
<p>​                    Connection：发送完后关闭TCP连接</p>
<p>​                    User-Agent：产生请求的浏览器类型</p>
<p>​                    Accept-language：客户端可识别的语言类型</p>
<p>​    实体体：当为GET方法时，实体体为空</p>
<p>​                    当为POST方法时，实体体为用户输入值（通常是提交表单操作）</p>
<h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p>​    初始状态行：协议版本字段</p>
<p>​                            状态码和相应状态信息：200 OK、301 Moved Permanently 、404 Not Found 等</p>
<p>​    首部行： Connection：发送完后关闭TCP连接</p>
<p>​    ·                Date：相应日期和时间</p>
<p>​                    Server：服务器</p>
<p>​                    Last-Modified：对象创建或最后修改的时间</p>
<p>​                    Content-length：发送对象的字节数</p>
<p>​                    Content-type：实体体中对象的格式，eg html</p>
<p>​    实体体</p>
<h5 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h5><p>​    浏览器创建一个到Web缓存的TCP连接，向Web缓存发送HTTP请求：</p>
<p>​            若本地有副本，则响应HTTP并返回该对象</p>
<p>​            若本地没有副本，则创建一个到初始服务器的TCP连接，向初始服务器发送HTTP请求，接收到初始服务器响应后进行本地缓存并向浏览器返回结果</p>
<p>​    Web缓存既是服务器也是客户</p>
<p>​            服务器：接受浏览器的请求并返回响应</p>
<p>​            客户：向初始服务器发送请求并接受响应</p>
<p>​    条件GET：通过If-modified-since判断缓存中的对象是否是最新的</p>
<p>​                      若自指定日期后对该对象修改过，才发送该对象，否则条件GET的响应报文实体为空</p>
<h4 id="•-SMTP-Simple-Mail-Transfer-Protocol-简单邮件传输协议"><a href="#•-SMTP-Simple-Mail-Transfer-Protocol-简单邮件传输协议" class="headerlink" title="•   SMTP   Simple Mail Transfer Protocol 简单邮件传输协议"></a>•   <strong>SMTP   Simple Mail Transfer Protocol</strong> <strong>简单邮件传输协议</strong></h4><p>​    电子邮件系统的组成：<strong>用户代理</strong>、<strong>邮件服务器</strong>、<strong>简单邮件传输协议</strong></p>
<p>​    用于发送方发送邮件至发送方的邮件服务器</p>
<p>​    以及从发送方的邮件服务器发送邮件至接收方的邮件服务器</p>
<p>​    SMTP的报文格式：7比特ASCII码格式</p>
<h4 id="•-POP3-Post-Office-Protocol-–-version-3-第三版邮局协议"><a href="#•-POP3-Post-Office-Protocol-–-version-3-第三版邮局协议" class="headerlink" title="•   POP3   Post Office Protocol – version 3 第三版邮局协议"></a>•   <strong>POP3   Post Office Protocol – version 3</strong> <strong>第三版邮局协议</strong></h4><h4 id="•-IMAP-Internet-Message-Access-Protocol-因特网邮件访问协议"><a href="#•-IMAP-Internet-Message-Access-Protocol-因特网邮件访问协议" class="headerlink" title="•   IMAP   Internet Message Access Protocol  因特网邮件访问协议"></a>•   <strong>IMAP   Internet Message Access Protocol</strong>  <strong>因特网邮件访问协议</strong></h4><p>​    此二者用于从接收方的服务器发送邮件至接收方</p>
<h4 id="•-DNS-Domain-Name-System-域名系统"><a href="#•-DNS-Domain-Name-System-域名系统" class="headerlink" title="•   DNS    Domain Name System 域名系统"></a>•   <strong>DNS    Domain Name System</strong> <strong>域名系统</strong></h4><p>​    <strong>运行在UDP之上，速度快，避免创建时延</strong></p>
<p>​    进行主机名到IP地址的转换，可用于寻找目的web的IP地址（HTTP需要）</p>
<p>​    DNS通过分布式数据库存储IP地址和主机名的集合</p>
<p>​    DNS功能：IP地址转换、主机别名、邮件服务器别名、负载分配</p>
<p>​    分布式层次查找：根DNS服务器、顶级DNS服务器、权威DNS服务器、本地DNS服务器</p>
<h5 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h5><p>​        源主机向他所在的本地DNS服务器发送DNS查询报文，本地DNS服务器将其转发到根DNS服务器，根据主机名的层层拆分，不断向根DNS服务器、顶级DNS服务器、权威DNS服务器查询主机名，最终确定主机名直接向目的主机发送IP查询，获取到IP地址。DNS既可以递归查询，也可以迭代查询</p>
<h5 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h5><p>​        如果一台DNS服务器缓存了某IP主机地址对，查询到该服务器时可直接返回IP地址</p>
<h5 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h5><p>​        首部区域12字节：标识符：16比特，标识该查询以匹配请求与回答</p>
<p>​                                    标志：指出是查询报文（0）还是回答报文（1）</p>
<p>​                                    数量字段：说明数据区域出现的数量</p>
<p>​        问题区域：包含正在查询的信息，名字字段+类型字段</p>
<p>​        回答区域：包含最初请求的名字的资源记录</p>
<p>​        权威区域：其他权威服务器的记录</p>
<p>​        附加区域：附加的有用的信息</p>
<h4 id="•-DASH-Dynamic-Adaptive-Streaming-over-HTTP-经HTTP的动态适应性流"><a href="#•-DASH-Dynamic-Adaptive-Streaming-over-HTTP-经HTTP的动态适应性流" class="headerlink" title="•   DASH   Dynamic Adaptive Streaming over HTTP  经HTTP的动态适应性流"></a><strong>•   DASH   Dynamic Adaptive Streaming over HTTP  经HTTP的动态适应性流</strong></h4><p>​    客户动态的请求来自不同版本（速率不同）的数据块，根据可用带宽选择合适的速率版本的块</p>
<h4 id="•-CDN-Content-Distribution-Network-内容分发网"><a href="#•-CDN-Content-Distribution-Network-内容分发网" class="headerlink" title="•   CDN   Content Distribution Network  内容分发网"></a><strong>•   CDN   Content Distribution Network  内容分发网</strong></h4><p>​    使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p>
<p>​    两种服务器安置策略：</p>
<p>​    深入：靠近端用户部署，减少端用户和CDN集群之间的链路和路由器的数量</p>
<p>​    邀请做客：在关键位置建造大集群，通常将集群放置在因特网交换点</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><strong>运输层</strong></h2><p><strong>为应用程序之间提供端到端的逻辑通信</strong></p>
<p><img src="/images/7142610-8c83a040e6aebd52.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="•-demultiplexing-多路分解"><a href="#•-demultiplexing-多路分解" class="headerlink" title="•   demultiplexing    多路分解"></a>•   demultiplexing    多路分解</h4><p>​    将运输层报文段中的数据交付多艘正确的套接字</p>
<h4 id="•-multiplexing-多路复用"><a href="#•-multiplexing-多路复用" class="headerlink" title="•   multiplexing    多路复用"></a>•   multiplexing    多路复用</h4><p>​    从原主机不同套接字收集数据并封装生成报文段，然后将报文段传递到网络层</p>
<h4 id="•-套接字"><a href="#•-套接字" class="headerlink" title="•   套接字"></a>•   套接字</h4><p>​    套接字有唯一的标识符；每个报文段有特殊字符指示到哪个套接字</p>
<p>​    即源端口号字段和目的端口号字段</p>
<p>​    UDP套接字：二元组，目的IP地址+目的端口号</p>
<p>​            当目的IP地址和目的端口号相同时将被分到相同的进程</p>
<p>​    TCP套接字：四元组，源IP地址+源端口号+目的IP地址+目的端口号</p>
<p>​            当源IP地址或源端口号不同时将被分到两个不同的进程</p>
<h4 id="•-IP地址和端口号"><a href="#•-IP地址和端口号" class="headerlink" title="•   IP地址和端口号"></a>•   IP地址和端口号</h4><p>​    一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的</p>
<p>​    无论是客户端还是服务器端，都对应一个或多个特定的端口号，每个端口对应一个唯一的程序</p>
<p>​    ftp：23，telnet：23，smtp：25，dns：53，http：80，https：443</p>
<h4 id="•-UDP-User-Datagram-Protocol-用户数据报协议"><a href="#•-UDP-User-Datagram-Protocol-用户数据报协议" class="headerlink" title="•   UDP    User Datagram Protocol   用户数据报协议"></a>•   <strong>UDP    User Datagram Protocol</strong>   <strong>用户数据报协议</strong></h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>​        立即发送</p>
<p>​        无连接：发送方和接收方的运输层实体没有握手的过程，不会引入建立连接的时延</p>
<p>​        不可靠服务：不能保证数据到达接收端，到达也可能是错误、乱序的</p>
<p>​        能发现差错但无法恢复：观察<strong>检验和</strong>的比特是否发生了改变，但没有差错恢复能力，智能丢弃受损的报文段</p>
<p>​        分组首部开销小：8字节</p>
<p>​        没有拥塞控制</p>
<h5 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h5><p>​        首部四个字段：源端口号、目的端口号、长度、校验和</p>
<h4 id="•-可靠传输协议"><a href="#•-可靠传输协议" class="headerlink" title="•   可靠传输协议"></a>•   可靠传输协议</h4><h5 id="rdt1-0——经完全可靠信道的传输"><a href="#rdt1-0——经完全可靠信道的传输" class="headerlink" title="rdt1.0——经完全可靠信道的传输"></a>rdt1.0——经完全可靠信道的传输</h5><h5 id="rdt2-0——经由比特差错新到的传输"><a href="#rdt2-0——经由比特差错新到的传输" class="headerlink" title="rdt2.0——经由比特差错新到的传输"></a>rdt2.0——经由比特差错新到的传输</h5><p>​            <strong>ARQ    Automatic Repeat-reQuest    自动重传请求</strong></p>
<p>​            差错检测：检测是否产生比特错误</p>
<p>​            接收方反馈：接受者发送肯定确认ACK，或否定确认NAK</p>
<p>​            重传：接收方收到有差错的分组，发送方重传</p>
<h5 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h5><p>​            rdt2.0没有考虑ACK或NAK的受损</p>
<p>​            当收到错误的ACK或NAK分组后，发送方进行重传（此时需解决冗余问题）</p>
<p>​            <strong>添加分组序号</strong>，接收方检查当前分组是否经过重传</p>
<h5 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h5><p>​            取消NAK设定，改成发送<strong>冗余ACK</strong></p>
<p>​            <strong>累计确认</strong></p>
<p>​            <strong>发送方需确认ACK的序号，判断是当前分组的ACK（成功无差错）或是已经接受到的最后一个正确分组的ACK（冗余ACK，此次分组有错）</strong></p>
<h5 id="rdt3-0——经由比特差错的丢包信道的传输"><a href="#rdt3-0——经由比特差错的丢包信道的传输" class="headerlink" title="rdt3.0——经由比特差错的丢包信道的传输"></a>rdt3.0——经由比特差错的丢包信道的传输</h5><p>​            <strong>倒计数定时器</strong>，设定超时间隔</p>
<p>​            在超时间隔内若未收到ACK，则进行重传（即使只是ACK延迟，发送的冗余数据也可由序号解决）</p>
<p>​            发送分组开始时启动定时器，当超过时间间隔需要重传，重新启动定时器</p>
<p>​            若ACK有延迟在超时后才会到达，只要在新的超时间隔内收到，那么之后的小于该ACK的报文均不会重传，因为<strong>累计确认</strong></p>
<h4 id="•-Pipelined-Protocol-流水线协议"><a href="#•-Pipelined-Protocol-流水线协议" class="headerlink" title="•  Pipelined Protocol    流水线协议"></a>•  Pipelined Protocol    流水线协议</h4><p>​    区别于停等协议，可以让传送端同时传送多个封包不需等待确认</p>
<h5 id="•-GBN-Go-Back-N-回退N步"><a href="#•-GBN-Go-Back-N-回退N步" class="headerlink" title="•   GBN    Go-Back-N    回退N步"></a>•   <strong>GBN    Go-Back-N</strong>    <strong>回退N步</strong></h5><p>​    <strong>累计确认</strong></p>
<img src="/images/QQ图片20210622124727.jpg" srcset="/img/loading.gif" lazyload style="zoom: 33%;">



<p>​    发送方：    </p>
<p>​        上层调用：检查当前窗口是否已满，是否有n个已发送但还未确认的分组</p>
<p>​        收到ACK：累计确认的方式</p>
<p>​        超时事件：一旦超时重传所有已发送但还未确认的分组</p>
<p>​    接收方：</p>
<p>​        <strong>丢弃所有失序分组</strong>，丢弃后返回最大已确认序号的ACK（符合累计确认）</p>
<h5 id="•-SR-Selective-Repeat-选择重传"><a href="#•-SR-Selective-Repeat-选择重传" class="headerlink" title="•   SR   Selective Repeat    选择重传"></a>•   <strong>SR   Selective Repeat</strong>    <strong>选择重传</strong></h5><p>​    <strong>逐个确认</strong></p>
<p>​    发送方仅重传那些丢失或受损的分组，避免不必要的重传</p>
<p>​    接收方若收到以前没收到过的序号的分组，将他们缓存；若等于当前基序号，则将它以及之前缓存的多个有序的分组一并交付给上层</p>
<img src="/images/QQ图片20210622124739.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>​    窗口大小规则：<strong>窗口长度必须小于或等于序号空间大小的一半</strong></p>
<h4 id="•-TCP-Transmission-Control-Protocol-传输控制协议"><a href="#•-TCP-Transmission-Control-Protocol-传输控制协议" class="headerlink" title="•   TCP    Transmission Control Protocol    传输控制协议"></a>•   <strong>TCP    Transmission Control Protocol</strong>    <strong>传输控制协议</strong></h4><h5 id="面向连接——三次握手："><a href="#面向连接——三次握手：" class="headerlink" title="面向连接——三次握手："></a>面向连接——三次握手：</h5><p>​            第一次：客户发送不包含应用层数据的报文段，将SYN位置为1，包含一个初始序号，<strong>SYN报文段</strong></p>
<p>​            第二次：服务器接收后返回允许连接的报文段，附带有服务器的初始序号，<strong>SYNACK报文段</strong></p>
<p>​            第三次：客户对允许连接进行确认，客户和服务器的初始序号加1，SYN位被置为0</p>
<p>​            意义：防止已失效的报文段。请求报文可能在某个失效时间到达服务器，如没有握手过程，服务器会默认有一个请求（实际上没有），服务器将一直等待</p>
<h5 id="拥塞控制——对路由而言："><a href="#拥塞控制——对路由而言：" class="headerlink" title="拥塞控制——对路由而言："></a>拥塞控制——对路由而言：</h5><h5 id="拥塞的代价"><a href="#拥塞的代价" class="headerlink" title="拥塞的代价"></a>拥塞的代价</h5><p>​            当分组速率到达链路容量时，分组经历巨大的排队时延</p>
<p>​            发送方必须重传以弥补因缓存溢出而丢弃的分组</p>
<p>​            在较大时延时不必要的重传和转发</p>
<p>​        因此一旦产生丢包意味着拥塞发生，应降低发送方的发送速率</p>
<h5 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h5><p>​            慢启动：发送方希望快速找到可用带宽的数量，拥塞窗口（cwnd）从1开始，每个RTT内2的指数级增加，一旦到达threshold转入拥塞避免模式</p>
<p>​            拥塞避免：每个RTT只将cwnd的值增加一个MSS</p>
<p>​            3个冗余的ACK的丢包：cwnd的值变为一半，threshold也变为一半</p>
<p>​            超时指示的丢包：cwnd降为1，threshold变为一半</p>
<h5 id="流量控制——对接收方而言"><a href="#流量控制——对接收方而言" class="headerlink" title="流量控制——对接收方而言"></a>流量控制——对接收方而言</h5><p>​            消除缓存溢出的可能性</p>
<p>​            接收方告知发送方缓存中还有多少可用的空间，应保证发送方发送到连接上但还未被确认的数据小于可用缓存</p>
<h5 id="可靠服务"><a href="#可靠服务" class="headerlink" title="可靠服务"></a>可靠服务</h5><p>​            累计确认，rdt3.0的模式</p>
<h5 id="差错恢复"><a href="#差错恢复" class="headerlink" title="差错恢复"></a>差错恢复</h5><h5 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h5><p>​    源端口号、目的端口号</p>
<p>​    32字节的序号字段和32字节的确认号字段：用来保证可靠传输</p>
<p>​    16比特接收窗口字段：用于流量控制</p>
<p>​    首部长度：通常为20字节</p>
<p>​    标志字段：ACK、RST、SYN、FIN、PSH、URG</p>
<img src="/images/QQ截图20210621210001.png" srcset="/img/loading.gif" lazyload style="zoom:80%;">

<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h2><h4 id="•-两个相互作用的部分-数据平面和控制平面"><a href="#•-两个相互作用的部分-数据平面和控制平面" class="headerlink" title="•  两个相互作用的部分    数据平面和控制平面"></a>•  两个相互作用的部分    数据平面和控制平面</h4><p>​        数据平面：从输入链路想输出链路转发数据报</p>
<p>​        控制平面：协调每个路由器的转发，选择路径进行传送</p>
<h4 id="•-两大核心作用-转发和路由"><a href="#•-两大核心作用-转发和路由" class="headerlink" title="•  两大核心作用    转发和路由"></a>•  两大核心作用    转发和路由</h4><h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>​                将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地操作</p>
<p>​                路由器将分组移动到合适的输出链路，每个路由均有<strong>转发表</strong>，存储对应首部和其输出</p>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>​                确定分组从源到目的地所采取的端到端路径的网络范围处理过程，选择从发送方到接收方的路径</p>
<h4 id="•-Routing-路由器"><a href="#•-Routing-路由器" class="headerlink" title="•  Routing    路由器"></a>•  Routing    路由器</h4><h5 id="路由结构"><a href="#路由结构" class="headerlink" title="路由结构"></a>路由结构</h5><p>​        输入端口：通过查询转发表决定路由器的输出端口</p>
<p>​        交换结构：将路由器的输入端口连接到输出端口</p>
<p>​        输出端口：在输出链路上传输分组</p>
<p>​        路由选择处理器：执行控制平面功能，计算和维护转发表</p>
<h5 id="转发表"><a href="#转发表" class="headerlink" title="转发表"></a>转发表</h5><p>​        <strong>最长前缀匹配</strong>，相同前缀的一组目的地址分配到同一个输出接口</p>
<h5 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h5><p>​        经内存交换：产生中断，将分组复制到处理器内存与输出端口的缓存</p>
<p>​        经总线交换：经由一根共享总线将分组直接传送到输出端口</p>
<p>​        经互联网络交换：纵横式网络，能够并行转发多个分组</p>
<h5 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h5><p>​        输入排队：多个分组发往同一个输出端口，会产生阻塞且必须在其队列中等待（该队列中后续也无法发送），交换结构一次只能传送一个分组到指定端口</p>
<p>​        输出排队：当一个分组在输出链路中发送时，又有多个分组到达输出端口，输出端口阻塞，交换结构传输速率大于输出链路发送速率</p>
<h5 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h5><p>​        FIFO：先来先服务</p>
<p>​        优先级服务：按优先级大小选择最高优先权队列的分组发送</p>
<p>​        循环和加权公平排队</p>
<h4 id="•-IP-Internet-Protocol-网际协议"><a href="#•-IP-Internet-Protocol-网际协议" class="headerlink" title="•   IP      Internet Protocol      网际协议"></a>•   <strong>IP      Internet Protocol</strong>      <strong>网际协议</strong></h4><p>​    尽力而为交付服务，但不做任何的确保，<strong>不可靠</strong></p>
<h5 id="IPv4数据报首部"><a href="#IPv4数据报首部" class="headerlink" title="IPv4数据报首部"></a>IPv4数据报首部</h5><p>​            版本号：4比特，表示该IP数据报使用的IP协议版本，iPv4为4</p>
<p>​            首部长度：4比特，表示IP数据报的载荷，无选项的情况下为20字节</p>
<p>​            服务类型（TOS）：区别不同类型的IP数据报</p>
<p>​            数据报长度：16比特，表示整个IP数据报的长度（报头区+数据区）</p>
<p>​            <strong>标识、标志、片偏移</strong>：与IP分片有关</p>
<p>​            <strong>TTL</strong>——生存时间：数据报可以经过的最大路由器数，每经过一个处理它的路由器，值减1，当该字段为0时，数据报就丢弃</p>
<p>​            协议：承载的各种上层协议</p>
<p>​            <strong>首部检验和</strong>：检测收到的IP数据报的比特错误</p>
<p>​            源和目的IP地址：32位</p>
<h5 id="IP分片："><a href="#IP分片：" class="headerlink" title="IP分片："></a>IP分片：</h5><p>​            <strong>MTU</strong>——最大传送单元：一个链路层帧能承载的最大数据量</p>
<p>​            以太网承载量：1500字节</p>
<p>​            标识：将发送的每个数据报的标识加1</p>
<p>​            标志：最后一个片的标志为0，其余为1</p>
<p>​            片偏移：指定该片放在初始IP数据报的哪个位置</p>
<h5 id="ipv6数据报首部"><a href="#ipv6数据报首部" class="headerlink" title="ipv6数据报首部"></a>ipv6数据报首部</h5><p>​            版本号：4比特，表示该IP数据报使用的IP协议版本，ipv6为6</p>
<p>​            流量类型、有效载荷长度、下一个首部、跳限制（这些与iPv4对应字段差不多）</p>
<p>​            <strong>流标签</strong>：20比特，表示一条数据报的流，对来自某些应用的数据报给出更高的优先权</p>
<p>​            <strong>扩大容量的源和目的地址</strong>：128位</p>
<h4 id="•-CIDR-Classless-Inter-Domain-Routing-无类别域间路由选择"><a href="#•-CIDR-Classless-Inter-Domain-Routing-无类别域间路由选择" class="headerlink" title="•   CIDR    Classless Inter-Domain Routing    无类别域间路由选择"></a>•   CIDR    Classless Inter-Domain Routing    无类别域间路由选择</h4><p>​    IP地址以子网掩码的形式给出：<strong>a.b.c.d&#x2F;x</strong></p>
<p>​    x位最高比特称为地址的前缀，一个子网下的主机拥有相同的前缀</p>
<p>​    分类编址：24位网络位（网络号）和8位主机位</p>
<p>​    对应分类编址（A、B、C类为可分配IP地址）：A类网络（&#x2F;8）、B类网络（&#x2F;16）、C类网络（&#x2F;24）、广播地址（255.255.255.255）</p>
<h4 id="•-DHCP-Dynamic-Host-Configuration-Protocol-动态主机配置协议"><a href="#•-DHCP-Dynamic-Host-Configuration-Protocol-动态主机配置协议" class="headerlink" title="•   DHCP  Dynamic Host Configuration Protocol  动态主机配置协议"></a>•   <strong>DHCP  Dynamic Host Configuration Protocol</strong>  <strong>动态主机配置协议</strong></h4><p>​    为主机分配一个临时的IP地址</p>
<p>​    <strong>DHCP服务器发现</strong>：要找一个与其交互的DHCP服务器，发送<strong>DHCP发现报文</strong>（discover），向所有与该子网连接的节点<strong>广播</strong></p>
<p>​    <strong>DHCP服务器提供</strong>：DHCP服务器收到发现报文后，用<strong>DHCP提供报文</strong>（offer）向客户做出响应；DHCP提供报文包含可分配的IP地址、IP地址租用期等信息</p>
<p>​    <strong>DHCP请求</strong>：从一个或多个服务器中选择一个，发送包含对应IP地址的<strong>DHCP请求报文</strong>（request），此处目的地址仍使用广播地址，告知其他DHCP服务器自己已选定某个服务器</p>
<p>​    <strong>DHCP ACK</strong>：服务器最终响应</p>
<h4 id="•-NAT-Network-Address-Translation-网络地址转换"><a href="#•-NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="•   NAT    Network Address Translation 网络地址转换"></a>•   <strong>NAT    Network Address Translation</strong> <strong>网络地址转换</strong></h4><p>​    一个网络号仅在其子网范围内有意义（全世界相同的IP地址很多，公网上不可能使用）</p>
<p>​    使私有网络IP地址经过转换能在公共网络中使用，或将公共网络IP地址转化为私有网络的IP地址（在一个子网内部使用私有地址是可以的）</p>
<h5 id="NAT优点"><a href="#NAT优点" class="headerlink" title="NAT优点"></a>NAT优点</h5><p>​        只需从ISP申请一个IP地址即可；本地网络IP地址变更无须告知外界；变更ISP无需修改内网的IP；内网对外网不可见，安全</p>
<h5 id="NAT实现"><a href="#NAT实现" class="headerlink" title="NAT实现"></a>NAT实现</h5><p>​        替换：利用NAT的IP地址和端口号替换每个外出数据报的IP地址和端口号</p>
<p>​        记录：每对IP地址和端口号记录在<strong>NAT转换表</strong>中</p>
<p>​        替换：根据NAT转换表替换进入内网数据报的IP地址和端口号</p>
<h4 id="•-链路状态路由选择算法-LS-算法"><a href="#•-链路状态路由选择算法-LS-算法" class="headerlink" title="•   链路状态路由选择算法    LS 算法"></a>•   链路状态路由选择算法    LS 算法</h4><p>​    对每个节点构造从源节点沿着向它的最短路径上的前一个节点</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1</span>、初始化：<br>   N&#x27; = &#123;u&#125;                                                                                      <br>   <span class="hljs-keyword">for</span> all nodes <span class="hljs-keyword">for</span> n                                                                   <br>        <span class="hljs-keyword">if</span> n is a neighbor <span class="hljs-keyword">of</span> u                                                      <br>            <span class="hljs-keyword">then</span> <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> = c(u，n)                                                        <br>        <span class="hljs-keyword">else</span> <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> = ∞                                                                     <br><br><span class="hljs-number">2</span>、循环阶段<br>    find w not <span class="hljs-keyword">in</span> N&#x27; such that <span class="hljs-constructor">D(<span class="hljs-params">w</span>)</span> is a minimum     对于没有在节点子集上的点，找出前一次迭代结束后具有最低开销的点              <br>    add w <span class="hljs-keyword">to</span> N&#x27;                                                                            <br>    update <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> <span class="hljs-keyword">for</span> each neighbor n <span class="hljs-keyword">of</span> w <span class="hljs-keyword">and</span> not <span class="hljs-keyword">in</span> N&#x27;    更新最短消耗     <br>        <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> = min( <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span>， <span class="hljs-constructor">D(<span class="hljs-params">w</span>)</span> + c(w，n) ）                              <br>    until N&#x27; = N                         节点全部遍历过                                                   <br><br></code></pre></td></tr></table></figure>

<h4 id="•-距离向量路由选择算法-DV-算法"><a href="#•-距离向量路由选择算法-DV-算法" class="headerlink" title="•   距离向量路由选择算法    DV 算法"></a>•   距离向量路由选择算法    DV 算法</h4><p>​    <img src="/images/gif.png" srcset="/img/loading.gif" lazyload></p>
<p>​    c表示从结点x到邻接结点v的费用，d表示从邻接结点v到目的结点y的最小费用路径的费用</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs llvm">对每个结点<span class="hljs-keyword">x</span>进行如下操作：<br>    初始化：<br>        遍历所有网络中的所有目的地y：<br>            初始化为邻接节点的距离，如果是非邻接结点，那么距离为∞。<br>        遍历每个邻接结点 w：<br>            初始化邻接结点 w 的距离向量<br>        遍历每个邻接结点 w:  <br>            发送本结点 <span class="hljs-keyword">x</span> 的距离向量到每个邻接结点 w。<br>    <br>    循环：<br>        等待（知道存在链路状态变化或者收到其他结点的距离向量之后终止等待）<br>        遍历网络 N 中的每个结点 y：<br>            依照bellman-ford方程更新本地 <span class="hljs-keyword">x</span> 距离向量<br>        如果 <span class="hljs-keyword">x</span> 的距离向量存在变化<br>            发送 <span class="hljs-keyword">x</span> 的距离向量给每一个邻居结点<br></code></pre></td></tr></table></figure>



<h4 id="•-OSPF-Open-Shortest-Path-First-开放式最短路径优先"><a href="#•-OSPF-Open-Shortest-Path-First-开放式最短路径优先" class="headerlink" title="•   OSPF   Open Shortest Path First  开放式最短路径优先"></a>•   <strong>OSPF   Open Shortest Path First</strong>  <strong>开放式最短路径优先</strong></h4><p>​    <strong>自治系统AS</strong>：由一组通常处在相同管理控制下的路由器组成</p>
<p>​    OSFP是一个链路状态协议，<strong>是自治系统AS内部的路由选择协议</strong></p>
<h5 id="OFPF工作实现"><a href="#OFPF工作实现" class="headerlink" title="OFPF工作实现"></a>OFPF工作实现</h5><p>​        每个路由器按照LS算法获知自己到所在AS内其他路由器的最短路径</p>
<p>​        使用OSFP时，路由器向AS内的所有其他路由器广播路由选择信息</p>
<p>​        当一条链路状态发生改变时，路由器就会广播链路状态信息；即使没有改变，路由器也会周期性的广播链路状态信息</p>
<h5 id="OSPF特点"><a href="#OSPF特点" class="headerlink" title="OSPF特点"></a>OSPF特点</h5><p>​        安全：仅由受信任的路由器能参与一个AS内的OSPF协议，所有OSPF报文在认证之后才能使用</p>
<p>​        多条相同开销的路径：可以均衡负载，分散数据</p>
<p>​        对单播与多播路由选择的综合支持</p>
<p>​        <strong>支持单个AS内的层次结构</strong>：OSPF最大优点</p>
<p>​                一个AS由一个主干区和多个局部区组成：主干由区边界路由器、主干路由器（计算路由）和AS边界路由器（连接其他AS）构成</p>
<p>​                区边界路由器：汇总到达所在区的距离，并告知其他区边界路由器</p>
<p>​                链路通告仅限于区内，每个路由器掌握所在AS的详细拓扑，但不知道其他区的信息</p>
<p>​                </p>
<img src="/images/QQ截图20210622173442.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;">



<h4 id="•-BGP-Border-Gateway-Protocol-边界网关协议"><a href="#•-BGP-Border-Gateway-Protocol-边界网关协议" class="headerlink" title="•   BGP  Border Gateway Protocol  边界网关协议"></a>•   <strong>BGP  Border Gateway Protocol</strong>  <strong>边界网关协议</strong></h4><p>​    <strong>ISP之间的路由选择协议</strong></p>
<h5 id="BGP作用："><a href="#BGP作用：" class="headerlink" title="BGP作用："></a>BGP作用：</h5><p>​        从邻居AS获得前缀的可达性信息：允许每个子网向其他子网通告信息</p>
<p>​        确定到该前缀的最好路由</p>
<h5 id="BGP连接："><a href="#BGP连接：" class="headerlink" title="BGP连接："></a>BGP连接：</h5><p>​        eBGP：外部BGP，跨越两个AS之间的连接，从邻居AS获取可达性信息</p>
<p>​        iBGP：内部BGP，相同AS的两台路由器之间的连接，向所有AS内部路由器传递可达性信息</p>
<h5 id="BGP属性："><a href="#BGP属性：" class="headerlink" title="BGP属性："></a>BGP属性：</h5><p>​        AS-PATH：已经通过的AS列表</p>
<p>​        NEXT-HOP：AS-PATH起始路由器接口的IP地址，两个AS之间互相连接的边界路由器的接口IP地址</p>
<p>​        eg：AS2 AS3 x 表示AS3中的x路由器的路径</p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210622191007.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="BGP的路由选择："><a href="#BGP的路由选择：" class="headerlink" title="BGP的路由选择："></a>BGP的路由选择：</h5><p>​        热土豆算法：只关注当前能到的具有最小开销的路径，而不管之后的路径开销</p>
<p>​        路由器选择算法：若路由被指派了一个本地偏好，则选择具有最高本地偏好值的路由；若本地偏好值相同，则选择具有最短AS-PATH的路由；若两者都相同，则选择最靠近NEXT-HOP的路由</p>
<h4 id="•-ICMP-Internet-Control-Message-Protocol-因特网控制报文协议"><a href="#•-ICMP-Internet-Control-Message-Protocol-因特网控制报文协议" class="headerlink" title="•   ICMP   Internet Control Message Protocol  因特网控制报文协议"></a>•   <strong>ICMP   Internet Control Message Protocol</strong>  <strong>因特网控制报文协议</strong></h4><p>​    差错报告（返回错误报文）、网络探询</p>
<p>​    承载在IP分组中，作为IP的有效载荷</p>
<h5 id="ICMP报文构成："><a href="#ICMP报文构成：" class="headerlink" title="ICMP报文构成："></a>ICMP报文构成：</h5><p>​            一个<strong>类型字段</strong>、一个<strong>编码字段</strong>，并且包含首次生成的IP数据报的首部和前8个字节，包括源和目的IP地址，源和目的端口号等</p>
<img src="/images/QQ截图20210622191741.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;">

<h5 id="差错报告发送情况："><a href="#差错报告发送情况：" class="headerlink" title="差错报告发送情况："></a>差错报告发送情况：</h5><p>​            产生错误报文时发送ICMP差错报告，eg：TTL超期（减到0），路由器丢弃数据报并发送ICMP告警报文</p>
<p>​            若IP数据报被分片，只有第一个IP数据报分片发送差错报告，后续均不发送</p>
<p>​            多播IP数据报均不发送差错报告</p>
<p>​            特殊地址（如127.0.0.0）不发送差错报告</p>
<h4 id="•-SNMP-Simple-Network-Management-Protocol-简单网络管理协议"><a href="#•-SNMP-Simple-Network-Management-Protocol-简单网络管理协议" class="headerlink" title="•   SNMP   Simple Network Management Protocol  简单网络管理协议"></a><strong>•   SNMP   Simple Network Management Protocol  简单网络管理协议</strong></h4><p>​    用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文</p>
<h5 id="网络管理的组件："><a href="#网络管理的组件：" class="headerlink" title="网络管理的组件："></a>网络管理的组件：</h5><p>​            管理服务器：应用程序，控制网络管理信息的收集、处理、分析和显示，发起控制网络行为的动作</p>
<p>​            被管设备：有多个被管对象构成</p>
<p>​            管理信息库（MIB）：收集一个被管设备中每个被管对象的关联信息</p>
<p>​            网络管理代理：驻留在每个被管设备中，运行被管设备中的一个进程，该进程与管理服务器通信</p>
<p>​            网络管理协议：允许管理服务器查询被管设备的状态，并经过代理间接地在这些设备上采取行动</p>
<img src="/images/QQ图片20210622193305.jpg" srcset="/img/loading.gif" lazyload style="zoom: 50%;">

<h5 id="SNMP报文——PDU（协议数据单元）"><a href="#SNMP报文——PDU（协议数据单元）" class="headerlink" title="SNMP报文——PDU（协议数据单元）"></a>SNMP报文——PDU（协议数据单元）</h5><p>​            请求响应模式：向SNMP代理发送一个请求，代理收到后执行某些动作</p>
<p>​            陷阱报文：通知管理服务器产生了一个异常，导致了MIB对象值的改变</p>
<img src="/images/QQ图片20210622194810.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;">



<h4 id="•-SDN-Software-Defined-Network-软件定义网络"><a href="#•-SDN-Software-Defined-Network-软件定义网络" class="headerlink" title="•  SDN    Software Defined Network    软件定义网络"></a>•  SDN    Software Defined Network    软件定义网络</h4><p>​    使用openflow协议</p>
<h5 id="SDN体系结构的特征："><a href="#SDN体系结构的特征：" class="headerlink" title="SDN体系结构的特征："></a>SDN体系结构的特征：</h5><p>​            基于流的转发：能够基于运输层、网络层或链路层首部中的任意数量的首部字段值进行转发（传统IP数据报只能依据目的IP进行）</p>
<p>​            <strong>数据平面和控制平面分离</strong>：数据平面——<strong>网络交换机</strong>组成，在其流表中执行匹配加动作；控制平面——服务器和控制管理交换机流表的软件</p>
<p>​            网络控制功能：控制平面构成——<strong>SDN控制器</strong>和若干<strong>网络控制程序</strong></p>
<p>​            可编程的网络</p>
<img src="/images/QQ截图20210622154127.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<h5 id="SDN控制平面的3层次："><a href="#SDN控制平面的3层次：" class="headerlink" title="SDN控制平面的3层次："></a>SDN控制平面的3层次：</h5><p>​            通信层：SDN控制器和受控网络设备之间的通信</p>
<p>​            网络范围状态管理层：SDN最终的控制决定（如配置所有交换机的流表以取得端到端的转发、实现负载均衡等），需要控制器具有有关网络的最新状态信息</p>
<p>​            对于网络控制应用的程序层的接口：允许网络控制应用程序在状态管理层之间读写网络状态和流表</p>
<img src="/images/QQ图片20210622152430.jpg" srcset="/img/loading.gif" lazyload style="zoom: 33%;">



<p>​    通过远程控制器计算和分发转发表，以共每台路由器（在SDN中称作<strong>分组交换机</strong>）使用</p>
<p>​    交换机的行为：匹配加动作——匹配：查找IP地址；动作：将分组发送到有特定输出端口的交换结构</p>
<p>​    openflow——<strong>流表</strong></p>
<p>​            首部字段值的集合：</p>
<p>​            计数器集合：包括已经与该表相匹配的分组数量，以及自从该表上次更新以来的时间</p>
<p>​            当分组到达流表时所采取的动作的集合：包括转发到指定输出端口、丢弃该分组、复制该分组、发送到多个输出端口、重写首部字段</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a><strong>链路层</strong></h2><p><strong>负责通过一个链路从一个节点向另一个物理链路直接相邻的节点传递数据帧</strong></p>
<p>运行任何链路层协议的设备称为<strong>节点</strong>，通信路径连接相邻节点的通信信道称为<strong>链路</strong></p>
<h4 id="•-链路层提供的服务"><a href="#•-链路层提供的服务" class="headerlink" title="•  链路层提供的服务"></a>•  链路层提供的服务</h4><p>​    <strong>成帧</strong>：几乎所有的链路成协议都要将链路层帧封装起来，一个帧有一个数据字段和若干首部字段组成</p>
<p>​    <strong>链路接入</strong>：媒体访问控制协议（MAC）规定了链路传输规则，MAC地址标识帧的源和目的</p>
<p>​    <strong>可靠交付</strong>：通常用于易产生高差错率的链路（无线网络），保证无差错的经链路层移动每个网络层数据报，在低差错率的链路上较少使用（光纤、同轴电缆等）</p>
<p>​    <strong>差错纠正和检测</strong>：差错检测通常使用硬件实现，差错纠正能准确确定帧中出错的位置并纠正</p>
<p>​    <strong>全双工与半双工</strong>：全双工——两端点同时双向传输；半双工——两端点交替双向传输</p>
<h4 id="•-差错检测与纠正技术："><a href="#•-差错检测与纠正技术：" class="headerlink" title="•  差错检测与纠正技术："></a>•  差错检测与纠正技术：</h4><h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5><p>​            单个奇偶校验：在数据末端增加1位奇偶校验位，选择它的值使得这d+1个比特中1的总数为偶数个则为偶校验（奇数个则为奇校验），比较两者是否同奇或同偶</p>
<p>​            二位奇偶校验：对每行每列计算奇偶值，产生的i+j+1奇偶比特构成了链路层帧的差错检测比特，并且能根据行和列的索引定位差错比特并纠正</p>
<img src="/images/QQ图片20210622202233.jpg" srcset="/img/loading.gif" lazyload style="zoom: 50%;">

<h5 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h5><p>​            d比特数据看作多个k比特的整数的序列，对其求和，这个和的<strong>反码</strong>作为校验和，当接收方将其接受到的数据的和跟校验和相加，如果结果有一个比特不为1，说明出现了比特错误</p>
<h5 id="循环冗余检测CRC"><a href="#循环冗余检测CRC" class="headerlink" title="循环冗余检测CRC"></a>循环冗余检测CRC</h5><p>​            d比特的数据D，发送节点要将其发送给接收节点，它们之间必须协商一个r+1比特模式，我们将其表示为G,我们将要求G的最高位有效比特是1，且一个d比特的数据加上一个r比特的R,得到的d+r比特模式用摸2除法恰好能被G整除</p>
<p>​            CRC进行差错检测的原理：接收方用G去除接收到的d+r比特，如果余数为非零，则表示数据出错了</p>
<img src="/images/QQ图片20210622203926.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;">



<h4 id="•-MAC-Multiple-Access-Control-Protocol-多路访问控制"><a href="#•-MAC-Multiple-Access-Control-Protocol-多路访问控制" class="headerlink" title="•   **MAC   Multiple Access Control Protocol   **多路访问控制"></a>•   **MAC   Multiple Access Control Protocol   **多路访问控制</h4><h5 id="信道划分协议："><a href="#信道划分协议：" class="headerlink" title="信道划分协议："></a>信道划分协议：</h5><p>​            <strong>不会产生冲突</strong>，适用于网络负载较重的情况，网络负载较轻会产生资源浪费</p>
<p>​            <strong>时分复用TDM</strong>：将时间划分为时间帧，并将每个时间帧为 N 个时隙，把每个时隙分给 N 个节点中的一个</p>
<p>​            <strong>频分复用FDM</strong>：将 R bps的信道划分为不同的频段，每个频段 R&#x2F;N 的带宽，并把每个频率分给 N 个节点中的一个</p>
<p>​            <strong>码分多址CDMA</strong>：为每个节点分配一种不同的编码，每个节点用唯一的编码对发送的数据进行编码，能支持不同节点同时传输</p>
<h5 id="随机接入协议："><a href="#随机接入协议：" class="headerlink" title="随机接入协议："></a>随机接入协议：</h5><p>​            没有实现的节点协调，<strong>会冲突</strong>——检测冲突或从冲突中恢复</p>
<p>​            随机体现在——<strong>碰撞的节点在等待一个随机时延后重发帧</strong></p>
<p>​            <strong>时隙ALOHA</strong>：时间被划分成等长的时隙，一个时隙对应传输一帧的时间，节点只在时隙起点传输帧，若有碰撞则以概率p在后续的每个时隙里发送帧，最大效率为0.37</p>
<img src="/images/QQ截图20210622214410.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<img src="/images/QQ截图20210622214530.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;">

<p>​            <strong>ALOHA</strong>：不对时间进行划分，可以在任何时间发送，因此冲突率增大，避损时区为[t0 -1 ,t0+1]，仍以概率p重传该帧</p>
<p>​            纯ALOHA的效率要低于时隙ALOHA</p>
<img src="/images/QQ截图20210622214814.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p>​            <strong>CSMA  Carrier Sense Multiple Access  载波侦听多路访问</strong>：侦听信号是否空闲，空闲时发送帧</p>
<p>​            <strong>CSMA &#x2F; CD  Carrier Sense Multiple Access with Collision Detection    具有碰撞检测的载波侦听多路访问</strong></p>
<p>​                    监听到信道空闲才会发送帧，否则等待直到侦听没有信号能量时才开始传输帧</p>
<p>​                    边发送帧边检测冲突，若检测到其它信号，终止传输</p>
<h5 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h5><p>​            轮询协议：<strong>主节点</strong>以循环的方式轮询每个节点，告诉该节点能够传输的真的最大数量</p>
<p>​            令牌传递协议：以<strong>令牌</strong>的特殊帧在节点之间交换，当一个节点收到令牌时，仅当它有帧要发送时才持有令牌，否则传递给下一个节点</p>
<h4 id="•-ARP-Address-Resolution-Protocol-地址解析协议"><a href="#•-ARP-Address-Resolution-Protocol-地址解析协议" class="headerlink" title="•   ARP    Address Resolution Protocol  地址解析协议"></a>•   <strong>ARP    Address Resolution Protocol</strong>  <strong>地址解析协议</strong></h4><p>​    MAC 地址：标识一个帧从哪个接口发出到达哪个物理相连的其他接口</p>
<p>​    MAC地址和IP地址的区别：MAC可携带，可从一个局域网转移到另一个局域网，MAC地址唯一；IP地址不可携带，依赖于节点连接的子网，不唯一    </p>
<p>​    <strong>ARP作用</strong>：网络层IP地址和链路层地址MAC地址的转换，<strong>解析IP地址至MAC地址，获取某某IP主机的MAC地址</strong></p>
<p>​    <strong>ARP只能解析在同一个子网上的主机和路由器接口的IP地址</strong></p>
<h5 id="ARP实现"><a href="#ARP实现" class="headerlink" title="ARP实现"></a><strong>ARP实现</strong></h5><p>​        每台主机或路由器在其内存中具有一个<strong>ARP表</strong>，包含了<strong>IP地址到MAC地址</strong>的映射，以及一个TTL（超时会将该映射丢弃）</p>
<p>​        子网内发送：发送方构造一个ARP分组，包含发送和接收IP地址与MAC地址</p>
<p>​                                源主机广播ARP查询分组，以广播地址作为目的MAC地址，子网上的每个适配器收到该帧，检查自身IP是否与目的IP地址相同，若相同则返回一个响应的ARP分组，使源主机更新其ARP表</p>
<p>​        向子网外发送数据：子网A构造IP数据报，封装帧，并发送到路由器，其目的MAC地址为路由器R的左接口MAC地址</p>
<p>​                                        子网A成功发送帧，路由器接收帧并提取、解析IP数据报传输至上层IP（其间可进行NAT转换），获取目的MAC地址或者下一跳的地址（通过ARP解析得到）</p>
<p>​                                        R转发IP数据报（源和目的IP地址不变），封装帧，由R的右接口MAC发送至目的主机</p>
<p>​        当两台主机处在一个子网下，发送IP数据报不需要经由路由器转发</p>
<p>​        当两台主机处在一个子网下，可以通过ARP查询报文获取对方的MAC地址；不在一个子网下，无法通过ARP查询获得MAC地址</p>
<h4 id="•-Ethernet-以太网"><a href="#•-Ethernet-以太网" class="headerlink" title="•  Ethernet    以太网"></a>•  Ethernet    以太网</h4><h5 id="以太网数据报："><a href="#以太网数据报：" class="headerlink" title="以太网数据报："></a>以太网数据报：</h5><p>​            数据字段：承载了IP数据报，以太网的MTU是1500字节</p>
<p>​            目的地址：包含目的适配器的MAC地址</p>
<p>​            源地址：传输该帧到链路上的MAC地址</p>
<p>​            CRC：检测是否产生差错</p>
<p>​            前同步码：前7个字节的值均为10101010；最后一个字节为10101011，保证发送端与接收端的时钟同步</p>
<h5 id="以太网特点："><a href="#以太网特点：" class="headerlink" title="以太网特点："></a>以太网特点：</h5><p>​            无确认、无连接、不可靠</p>
<p>​            使用链路层协议：CSMA&#x2F;CD</p>
<h4 id="•-链路层交换机"><a href="#•-链路层交换机" class="headerlink" title="•  链路层交换机"></a>•  链路层交换机</h4><p>​    交换机的过滤和转发借助于<strong>交换机表</strong></p>
<h5 id="交换机表内容："><a href="#交换机表内容：" class="headerlink" title="交换机表内容："></a>交换机表内容：</h5><p>​            一个MAC地址、通向该MAC地址的交换机接口、表项放置在表中的时间</p>
<h5 id="交换机工作过程："><a href="#交换机工作过程：" class="headerlink" title="交换机工作过程："></a>交换机工作过程：</h5><p>​            目的MAC地址从交换机的接口x到达：</p>
<p>​            若表中没有该MAC地址的表项，则交换机向除接口x以外的所有接口广播该帧</p>
<p>​            若该MAC地址有一个与 x 相连的表项，无需将该帧转发至其他接口（本来就属于x），交换机丢弃该帧</p>
<p>​            若该MAC地址有一个与其他接口 y 相连的表项，则该帧被转发到与 y 相连的局域网内</p>
<h5 id="自学习："><a href="#自学习：" class="headerlink" title="自学习："></a>自学习：</h5><p>​            可以获知到达主机的接口信息</p>
<p>​            交换机表初始为空，对于每个接口收到的每个入帧，在表中存储：源地址字段中的MAC地址、该帧到达的接口、当前时间</p>
<p>​            如果在一段时间内交换机没有收到以该地址作为源地址的帧，则删除该表项</p>
<h5 id="交换机与路由器的比较："><a href="#交换机与路由器的比较：" class="headerlink" title="交换机与路由器的比较："></a>交换机与路由器的比较：</h5><p>​        相同：均为存储-转发设备，均使用转发表</p>
<p>​        相异：交换机是链路层设备，路由器是网络层设备；交换机通过自学习更新转发表，路由器通过路由算法更新转发表；交换机即插即用，无需配置，路由器并非即插即用，需要人为配置IP地址</p>
<h4 id="•-无线链路"><a href="#•-无线链路" class="headerlink" title="•   无线链路"></a>•   无线链路</h4><h5 id="无线与有线的区别："><a href="#无线与有线的区别：" class="headerlink" title="无线与有线的区别："></a>无线与有线的区别：</h5><p>​            递减的信号强度：电磁波有损，信号强度随着距离的的增加而减弱</p>
<p>​            来自其他源的干扰：同一个频段的电磁波会互相干扰</p>
<p>​            多径传播：经过反射和折射变为多径，使接收到的信号变模糊</p>
<p>​    <strong>信噪比 SNR</strong>：所收到的信号和噪声强度的相对值</p>
<p>​    <strong>比特差错率 BER</strong>：接收方收到有错比特的概率</p>
<p>​            对于给定的方案，SNR越高，BER越低——增加传输速率降低错帧概率</p>
<p>​            对于给定的SNR，具有较高比特传输率的调制技术将有较高的BER</p>
<h5 id="隐藏终端问题："><a href="#隐藏终端问题：" class="headerlink" title="隐藏终端问题："></a>隐藏终端问题：</h5><p>​            两台主机之间存在物体阻挡，或无线媒体传播时信号强度衰减过多，以至于不足以检测到对方的传输</p>
<h5 id="CDMA码分多址："><a href="#CDMA码分多址：" class="headerlink" title="CDMA码分多址："></a>CDMA码分多址：</h5><img src="/images/QQ图片20210623100815.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>​            </p>
<h4 id="•-无线网络-802-11——WiFi"><a href="#•-无线网络-802-11——WiFi" class="headerlink" title="•   无线网络    802.11——WiFi"></a>•   无线网络    802.11——WiFi</h4><p>​    基本结构：<strong>基本服务集 BSS</strong>：一个BSS 包含一个或多个无线站点和一个AP中央基站</p>
<img src="/images/QQ图片20210623100823.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p>​        AP设置：一个单字或双字的服务集标识符SSID，分配一个信道号</p>
<p>​        无线站点的加入：加入其中一个子网并与其中一个AP相关联（相当于提供用户名和密码）</p>
<p>​        802.11要求每个AP周期性的发送信标帧</p>
<h5 id="被动扫描与主动扫描"><a href="#被动扫描与主动扫描" class="headerlink" title="被动扫描与主动扫描"></a>被动扫描与主动扫描</h5><p>​        被动扫描：扫描信道和监听信标帧的过程</p>
<p>​        主动扫描：向位于无线主机范围内的所有AP广播探测帧</p>
<img src="/images/QQ图片20210623100820.jpg" srcset="/img/loading.gif" lazyload style="zoom: 50%;">

<h5 id="802-11的MAC协议：CSMA-x2F-CA"><a href="#802-11的MAC协议：CSMA-x2F-CA" class="headerlink" title="802.11的MAC协议：CSMA&#x2F;CA"></a>802.11的MAC协议：CSMA&#x2F;CA</h5><p>​        核心：避免碰撞而不是检测碰撞</p>
<p>​        当某站点最初监听到信道空闲，会在一个DIFS（分布式帧间间隔）的短时间后发送该帧</p>
<p>​        否则选取一个随机回退值，在信道空闲时递减该值，当值为0时发送整个数据帧并等待确认</p>
<p>​        若收到确认则表明成功发送；若未收到重新回退，在更大的随机范围内选取一个回退值</p>
<p>​        为何不用CSMA&#x2F;CD：<strong>无线网络的衰减很严重，在无线网络中难以检测到冲突；而以太网为有线链路，冲突反应强度大衰减小，易于检测</strong></p>
<p>​        链路层的确认方法：通过CRC校验后，等待一个SIFS时间（短帧间间隔）发回一个确认帧</p>
<h5 id="隐藏终端处理"><a href="#隐藏终端处理" class="headerlink" title="隐藏终端处理"></a>隐藏终端处理</h5><p>​        使用一个短请求发送（RTS）和一个短允许发送（CTS）来<strong>预约</strong>信道的访问，数据只有在预约后才能传输</p>
<p>​        发送方先发送一个RTS帧，指示传输帧和确认帧所需的总时间</p>
<p>​        AP收到RTS帧后广播一个CTS帧：给发送方明确的发送许可、指示其他站点在预约期内不要发送</p>
<img src="/images/QQ图片20210623102329.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<h5 id="802-11-帧结构"><a href="#802-11-帧结构" class="headerlink" title="802.11 帧结构"></a>802.11 帧结构</h5><img src="/images/QQ图片20210623102614.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>​        有效载荷：通常由IP数据报或者ARP分组构成</p>
<p>​        地址1：要接收该帧的无线站点的MAC地址</p>
<p>​        地址2：传输该帧的站点的MAC地址</p>
<p>​        地址3：第一跳的MAC地址</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/cs-learning/">cs learning</a>
                    
                      <a class="hover-with-bg" href="/categories/cs-learning/computer-networks/">computer networks</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/cs-leaning-01/">cs leaning_01</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/08/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>














  
<script src="/js/DynamicLine.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <script type="text/javascript" src="/js/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"left","hOffset":-30,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
