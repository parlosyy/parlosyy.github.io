<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Computer Programming —— graph</title>
    <link href="/2022/03/10/program2/"/>
    <url>/2022/03/10/program2/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵存储："><a href="#邻接矩阵存储：" class="headerlink" title="邻接矩阵存储："></a>邻接矩阵存储：</h4><p>有向图在uv位置加权重；若为无向图则uv和vu均更新</p><h4 id="邻接链表存储："><a href="#邻接链表存储：" class="headerlink" title="邻接链表存储："></a>邻接链表存储：</h4><p><img src="/images/cs_net/QQ截图20210618001720.png" style="zoom: 50%;"></p><h4 id="链式前向星存储："><a href="#链式前向星存储：" class="headerlink" title="链式前向星存储："></a>链式前向星存储：</h4><figure class="highlight stan"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">//链式前向星存储</span><br>struct EDGE<br>&#123;<br>    <span class="hljs-type">int</span> u, v, w, next;<br>&#125; e[maxn];<br><span class="hljs-type">int</span> <span class="hljs-built_in">head</span>[maxn];<br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> add(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)<br>&#123;<br>e[tot].u = u;<br>    e[tot].v = v;<br>    e[tot].w = w;<br>    e[tot].next = <span class="hljs-built_in">head</span>[u];<br>    <span class="hljs-built_in">head</span>[u] = tot;<br>    tot++;<br>&#125;<br><br>memset(<span class="hljs-built_in">head</span>, <span class="hljs-number">0</span>, sizeof(<span class="hljs-built_in">head</span>));<br></code></pre></td></tr></table></figure><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="邻接链表的dfs"><a href="#邻接链表的dfs" class="headerlink" title="邻接链表的dfs"></a>邻接链表的dfs</h4><p><img src="/images/cs_net/QQ截图20210618001825.png" style="zoom: 80%;"></p><h4 id="链式前向星的dfs"><a href="#链式前向星的dfs" class="headerlink" title="链式前向星的dfs"></a>链式前向星的dfs</h4><p><img src="/images/cs_net/QQ截图20210618001608.png" style="zoom:80%;"></p><h3 id="树的直径问题"><a href="#树的直径问题" class="headerlink" title="树的直径问题"></a>树的直径问题</h3><h4 id="树的直径一定是从一个叶子到另一个叶子，两遍dfs可得到答案"><a href="#树的直径一定是从一个叶子到另一个叶子，两遍dfs可得到答案" class="headerlink" title="树的直径一定是从一个叶子到另一个叶子，两遍dfs可得到答案"></a>树的直径一定是从一个叶子到另一个叶子，两遍dfs可得到答案</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void dfs(int u) &#123;<br>for (int i = 0, n = g<span class="hljs-comment">[u]</span>.size(); i &lt; n; i++) &#123;<br>if (!vis<span class="hljs-comment">[g<span class="hljs-comment">[u]</span><span class="hljs-comment">[i]</span>]</span>) &#123;<br>vis<span class="hljs-comment">[g<span class="hljs-comment">[u]</span><span class="hljs-comment">[i]</span>]</span> = 1;<br>maxn++;<br>if (maxn &gt; maxs) &#123;<br>maxs = maxn;<br>maxp = g<span class="hljs-comment">[u]</span><span class="hljs-comment">[i]</span>;<br>&#125;<br>dfs(g<span class="hljs-comment">[u]</span><span class="hljs-comment">[i]</span>);<br>maxn--;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>find函数查询x所在的代表元</p><p>unite函数实现两个集合的合并，将一个集合挂到另一个上</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> par[maxn]; <span class="hljs-comment">// 一个元素所在集合的代表元,par[i]为i的代表元</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> x) &#123;  <br><span class="hljs-keyword">if</span> (par[x] == x) <span class="hljs-comment">// 是其自己</span><br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> par[x] = <span class="hljs-keyword">find</span>(par[x]);<br>&#125;<br><br>bool unite(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) &#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-keyword">find</span>(x);<br><span class="hljs-keyword">int</span> b = <span class="hljs-keyword">find</span>(y);<br><span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>par[b] = a;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">// 初始化par[i] = i;</span><br></code></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>每次贪心地尝试将图中最小的非树边标记为树边，非法则跳过</p><p><img src="/images/cs_net/QQ截图20210618002325.png" style="zoom:80%;"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span> &#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> c;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> point&amp; p) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> c &lt; p.c; &#125;<br>&#125;;<br>vector&lt;point&gt; v;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (par[x] == x)<br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>par[b] = a;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">kur</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unite</span>(v[i].a, v[i].b)) &#123;<br>res += v[i].c;<br>count++;<br>&#125;<br><span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>用于求取图中任意两点之间的关系，多源最短路</p><p><img src="/images/cs_net/QQ截图20210618071943.png" alt></p><h3 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h3><p>用于求取没有负权边的单源最短路径</p><p><img src="/images/cs_net/QQ截图20210618072244.png" alt></p><p><img src="/images/cs_net/QQ截图20210618072256.png" alt></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void dijkstra(int s, int n)<br>&#123;<br>    priority_queue&lt;pa, vector&lt;pa&gt;, greater&lt;pa&gt;&gt; q;<br>    for (int i = 1; i &lt;= n; i++)<br>        dis<span class="hljs-comment">[i]</span> = inf, vis<span class="hljs-comment">[i]</span> = 0;<br>    dis<span class="hljs-comment">[s]</span> = 0;<br>    q.push(make_pair(0, s));<br>    while (!q.empty())<br>    &#123;<br>        int x = q.top().second;<br>        q.pop();<br>        if (vis<span class="hljs-comment">[x]</span>)<br>            continue;<br>        vis<span class="hljs-comment">[x]</span> = 1;<br>        for (int pos = head<span class="hljs-comment">[x]</span>; pos; pos = e<span class="hljs-comment">[pos]</span>.next)<br>        &#123;<br>            if (dis<span class="hljs-comment">[e<span class="hljs-comment">[pos]</span>.to]</span> &gt; dis<span class="hljs-comment">[x]</span> + e<span class="hljs-comment">[pos]</span>.w)<br>            &#123;<br>                dis<span class="hljs-comment">[e<span class="hljs-comment">[pos]</span>.to]</span> = dis<span class="hljs-comment">[x]</span> + e<span class="hljs-comment">[pos]</span>.w;<br>                q.push(make_pair(dis<span class="hljs-comment">[e<span class="hljs-comment">[pos]</span>.to]</span>, e<span class="hljs-comment">[pos]</span>.to));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="当遇到返回起点的问题，可以考虑用两个方向做两次dijkstra算法"><a href="#当遇到返回起点的问题，可以考虑用两个方向做两次dijkstra算法" class="headerlink" title="当遇到返回起点的问题，可以考虑用两个方向做两次dijkstra算法"></a>当遇到返回起点的问题，可以考虑用两个方向做两次dijkstra算法</h5><h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><p>cnt[x]表示 x 当前最短路上的边数</p><p><img src="/images/cs_net/QQ截图20210618074028.png" alt></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void init(int s)<br>&#123;<br>    for (int i = 1; i &lt;= n + 1; i++)<br>    &#123;<br>        dis<span class="hljs-comment">[i]</span> = inf;<br>        vis<span class="hljs-comment">[i]</span> = 0;<br>    &#125;<br>    dis<span class="hljs-comment">[s]</span> = 0;<br>    can<span class="hljs-comment">[s]</span> = 1;<br>&#125;<br>void spfa(int s)<br>&#123;<br>    init(s);<br>    queue&lt;int&gt; q;<br>    q.push(s);<br>    while (!q.empty()) //队列非空<br>    &#123;<br>        int u = q.front(); //取队首元素<br>        vis<span class="hljs-comment">[u]</span> = 0;<br>        q.pop();<br>        for (int i = head<span class="hljs-comment">[u]</span>; i; i = e<span class="hljs-comment">[i]</span>.next)<br>            if (dis<span class="hljs-comment">[e<span class="hljs-comment">[i]</span>.to]</span> &gt; dis<span class="hljs-comment">[u]</span> + e<span class="hljs-comment">[i]</span>.w)<br>            &#123;<br>                dis<span class="hljs-comment">[e<span class="hljs-comment">[i]</span>.to]</span> = dis<span class="hljs-comment">[u]</span> + e<span class="hljs-comment">[i]</span>.w;<br>                pre<span class="hljs-comment">[e<span class="hljs-comment">[i]</span>.to]</span> = u;<br>                if (!can<span class="hljs-comment">[e<span class="hljs-comment">[i]</span>.to]</span>)<br>                &#123;<br>                    can<span class="hljs-comment">[e<span class="hljs-comment">[i]</span>.to]</span> = 1;<br>                    q.push(e<span class="hljs-comment">[i]</span>.to);<br>                &#125;<br>            &#125; <br>        can<span class="hljs-comment">[u]</span> = 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长路问题"><a href="#最长路问题" class="headerlink" title="最长路问题"></a>最长路问题</h3><p><img src="/images/cs_net/QQ截图20210618074359.png" style="zoom:67%;"></p><h3 id="负权环路"><a href="#负权环路" class="headerlink" title="负权环路"></a>负权环路</h3><p>cnt[x] 表示 x 当前最短路上的边数</p><p>每次更新最短路时更新 cnt[v]，若某一时刻 cnt[v] 大于等于 n 的话，说明图中存在负环</p><p><img src="/images/cs_net/QQ截图20210618123330.png" style="zoom: 67%;"></p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>对于有向无环图求其满足边的依赖的排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// 优先级队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (in_deg[i] == <span class="hljs-number">0</span>) <span class="hljs-comment">// 入度为0 插入队列</span><br>            q.<span class="hljs-built_in">push</span>(i);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[t]; i; i = e[i].next)<br>        &#123;<br>            in_deg[e[i].to]--;<br>            <span class="hljs-keyword">if</span> (in_deg[e[i].to] == <span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(e[i].to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kosaraju-强连通分量算法"><a href="#kosaraju-强连通分量算法" class="headerlink" title="kosaraju 强连通分量算法"></a>kosaraju 强连通分量算法</h3><p>SCC强连通分量，一个scc内的所有点都两两可达</p><p>前序：第一次达到点x的次序，用d[x]表示<br>后序：x点遍历完成的次序，即回溯时间，用f[x]表示</p><p>第一遍dfs确定原图的逆后序序列<br>第二遍dfs在反图中按照逆后序序列进行遍历</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int <span class="hljs-keyword">c</span>[MAXN]<span class="hljs-punctuation">,</span> dfn[MAXN]<span class="hljs-punctuation">,</span> vis[MAXN]<span class="hljs-punctuation">,</span> dcnt<span class="hljs-punctuation">,</span> scnt<span class="hljs-punctuation">,</span> head[MAXN]<span class="hljs-comment">;</span><br>vector&lt;int&gt; g<span class="hljs-number">1</span>[MAXN]<span class="hljs-punctuation">,</span> g<span class="hljs-number">2</span>[MAXN]<span class="hljs-comment">; // g1原图，g2反图</span><br>struct node<br>&#123;<br>    int from<span class="hljs-punctuation">,</span> <span class="hljs-keyword">to</span><span class="hljs-comment">;</span><br>&#125; e[MAXN]<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>void dfs<span class="hljs-number">1</span>(int <span class="hljs-keyword">x</span>)<br>&#123;<br>    vis[<span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    for (auto y : g<span class="hljs-number">1</span>[<span class="hljs-keyword">x</span>])<br>    &#123;<br>        if (<span class="hljs-title">!vis</span>[y])<br>            dfs<span class="hljs-number">1</span>(y)<span class="hljs-comment">;</span><br>    &#125;<br>    dfn[++dcnt] <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span><span class="hljs-comment">;</span><br>&#125;<br>void dfs<span class="hljs-number">2</span>(int <span class="hljs-keyword">x</span>)<br>&#123;<br>    <span class="hljs-keyword">c</span>[<span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> scnt<span class="hljs-comment">;</span><br>    for (auto y : g<span class="hljs-number">2</span>[<span class="hljs-keyword">x</span>])<br>    &#123;<br>        if (<span class="hljs-title">!c</span>[y])<br>            dfs<span class="hljs-number">2</span>(y)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br>void kosaraju()<br>&#123;<br>    dcnt <span class="hljs-operator">=</span> scnt <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    memset(<span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> sizeof(<span class="hljs-keyword">c</span>))<span class="hljs-comment">;</span><br>    memset(vis<span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> sizeof(vis))<span class="hljs-comment">;</span><br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; i &lt;= n; i++)</span><br>        if (<span class="hljs-title">!vis</span>[i])<br>            dfs<span class="hljs-number">1</span>(i)<span class="hljs-comment">;</span><br>    for (int i <span class="hljs-operator">=</span> n<span class="hljs-comment">; i &gt;= 1; i--)</span><br>        if (<span class="hljs-title">!c</span>[dfn[i]])<br>            ++scnt<span class="hljs-punctuation">,</span> dfs<span class="hljs-number">2</span>(dfn[i])<span class="hljs-comment">;</span><br>&#125;<br><br>int main()<br>&#123;<br>    scanf(<span class="hljs-string">&quot;%d%d&quot;</span><span class="hljs-punctuation">,</span> &amp;n<span class="hljs-punctuation">,</span> &amp;m)<span class="hljs-comment">;</span><br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; i &lt;= m; i++)</span><br>    &#123;<br>        int a<span class="hljs-punctuation">,</span>b<span class="hljs-comment">;</span><br>        scanf(<span class="hljs-string">&quot;%d%d&quot;</span><span class="hljs-punctuation">,</span> &amp;a<span class="hljs-punctuation">,</span> &amp;b)<span class="hljs-comment">;</span><br>        e[i].from <span class="hljs-operator">=</span> a<span class="hljs-comment">;</span><br>        e[i].<span class="hljs-keyword">to</span> <span class="hljs-operator">=</span> b<span class="hljs-comment">;</span><br>        g<span class="hljs-number">1</span>[a].push_back(b)<span class="hljs-comment">;</span><br>        g<span class="hljs-number">2</span>[b].push_back(a)<span class="hljs-comment">;</span><br>    &#125;<br>    kosaraju()<span class="hljs-comment">;</span><br>    int ans <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; i &lt;= m; i++)</span><br>    &#123;<br>       int u <span class="hljs-operator">=</span> <span class="hljs-keyword">c</span>[e[i].from]<span class="hljs-punctuation">,</span> v <span class="hljs-operator">=</span> <span class="hljs-keyword">c</span>[e[i].<span class="hljs-keyword">to</span>]<span class="hljs-comment">;</span><br>        if (u !<span class="hljs-operator">=</span> v)<br>            head[v]++<span class="hljs-comment">; //表示有入度</span><br>    &#125;<br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; i &lt;= scnt; i++)</span><br>        if (<span class="hljs-title">!head</span>[i])<br>            ans++<span class="hljs-comment">; // scc个数</span><br>    cout &lt;&lt; ans &lt;&lt; endl<span class="hljs-comment">;</span><br>    return <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cs learning</category>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Programming —— structure</title>
    <link href="/2022/03/10/program1/"/>
    <url>/2022/03/10/program1/</url>
    
    <content type="html"><![CDATA[<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a><strong>BFS</strong></h2><p>每次从队列中选择未被访问过可到达的邻接点，并均标记为已访问过，将这些点加入到队列中</p><p>以此类推，直到队列为空</p><p><img src="/images/cs_net/QQ截图20210618154353.png" style="zoom: 50%;"></p><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><h5 id="对上下左右四个方向进行判断，看能否走到"><a href="#对上下左右四个方向进行判断，看能否走到" class="headerlink" title="对上下左右四个方向进行判断，看能否走到"></a>对上下左右四个方向进行判断，看能否走到</h5><p>不能走到的情况：已经走到过；到达边界；碰到障碍物</p><p><img src="/images/cs_net/QQ截图20210618153818.png" style="zoom: 50%;"></p><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>全排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> vis[maxn], a[maxn];<br><span class="hljs-comment">// vis记录是否使用过</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">permutation</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[i]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!vis[i])<br>        &#123;<br>            vis[i] = <span class="hljs-number">1</span>;<br>            a[x] = i;<br>            <span class="hljs-built_in">permutation</span>(x + <span class="hljs-number">1</span>, n);<br>            vis[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选数问题"><a href="#选数问题" class="headerlink" title="选数问题"></a>选数问题</h3><p>对于n个整数，计算出选取k个数，其和为素数共有多少种</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> *b, <span class="hljs-type">int</span> i,<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> <span class="hljs-keyword">level</span>,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">level</span> == k) &#123;<br><span class="hljs-keyword">if</span> (prime(m)) &#123;<br>sum++;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>dfs(b, j, m + b[j], <span class="hljs-keyword">level</span> + <span class="hljs-number">1</span>, k, n);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="区间调度"><a href="#区间调度" class="headerlink" title="区间调度"></a>区间调度</h3><p>找到最大的互相不重叠的区间</p><h5 id="左端点排序"><a href="#左端点排序" class="headerlink" title="左端点排序"></a>左端点排序</h5><p><img src="/images/cs_net/QQ截图20210618195944.png" style="zoom:67%;"></p><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><p><img src="/images/cs_net/QQ截图20210618203221.png" style="zoom:50%;"></p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p><img src="/images/cs_net/QQ截图20210618202105.png" style="zoom: 50%;"></p><h3 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h3><p><img src="/images/cs_net/QQ截图20210618202119.png" style="zoom:67%;"></p><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>将序列分成m段，每一段连续，并且<strong>重量和</strong>最大的段的<strong>和最小</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">existline</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> nowline = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cursum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (cursum + a[i] &gt; b) &#123;<br>nowline++;<br>cursum = a[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>cursum += a[i];<br>&#125;<br><span class="hljs-keyword">if</span> (nowline &gt;= m)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">existline</span>(mid)) &#123;<br>r = mid;<br>res = mid;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>l = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特殊数据结构"><a href="#特殊数据结构" class="headerlink" title="特殊数据结构"></a>特殊数据结构</h2><h3 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h3><p><img src="/images/cs_net/QQ截图20210618155039.png" style="zoom:50%;"></p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><img src="/images/cs_net/QQ截图20210618155146.png" style="zoom:50%;"></p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>通过分治转换</p><p><img src="/images/cs_net/QQ截图20210618155247.png" style="zoom:50%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 快速幂</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">qpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span><br>&#123;<br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (a %= p; b; a = a * a % p, b &gt;&gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><br><br><br><span class="hljs-comment">// 快速乘法</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">qmul</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod)</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (b) &#123;<br><span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)ans = (ans + a) % mod;<br>a = (a &lt;&lt; <span class="hljs-number">1</span>) % mod;<br>b &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><img src="/images/cs_net/QQ截图20210618155547.png" style="zoom:67%;"></p><p><img src="/images/cs_net/QQ截图20210618160108.png" style="zoom:50%;"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">// 预处理<br>sum<span class="hljs-comment">[x]</span><span class="hljs-comment">[y]</span> = sum<span class="hljs-comment">[x - 1]</span><span class="hljs-comment">[y]</span> + sum<span class="hljs-comment">[x]</span><span class="hljs-comment">[y - 1]</span> - sum<span class="hljs-comment">[x - 1]</span><span class="hljs-comment">[y - 1]</span> + m<span class="hljs-comment">[x]</span><span class="hljs-comment">[y]</span>;<br>// 求和<br>res = sum<span class="hljs-comment">[c]</span><span class="hljs-comment">[d]</span> - sum<span class="hljs-comment">[a - 1]</span><span class="hljs-comment">[d]</span> - sum<span class="hljs-comment">[c]</span><span class="hljs-comment">[b - 1]</span> + m<span class="hljs-comment">[a - 1]</span><span class="hljs-comment">[b - 1]</span>;<br></code></pre></td></tr></table></figure><h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p><img src="/images/cs_net/QQ截图20210618160232.png" style="zoom:50%;"></p><p>二维差分矩阵的具体实现</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for (int i = 0; i &lt; cnt; i++)<br>&#123;<br>    int lx, ly, rx, ry, C;<br>    cin &gt;&gt; lx &gt;&gt; ly &gt;&gt; rx &gt;&gt; ry &gt;&gt; C;<br>    b<span class="hljs-comment">[lx]</span><span class="hljs-comment">[ly]</span> += C;<br>    b<span class="hljs-comment">[lx]</span><span class="hljs-comment">[ry + 1]</span> -= C;<br>    b<span class="hljs-comment">[rx + 1]</span><span class="hljs-comment">[ly]</span> -= C;<br>    b<span class="hljs-comment">[rx + 1]</span><span class="hljs-comment">[ry + 1]</span> += C;<br>&#125;<br>for (int i = 1; i &lt;= n; i++)<br>&#123;<br>    for (int j = 1; j &lt;= m; j++)<br>    &#123;<br>        res<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = res<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + res<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span> - res<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> + b<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><img src="/images/cs_net/QQ截图20210618192538.png" style="zoom:67%;"></p><h4 id="直方图面积问题"><a href="#直方图面积问题" class="headerlink" title="直方图面积问题"></a>直方图面积问题</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle">x[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>x[n + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxs = <span class="hljs-number">0</span>;<br>s.<span class="hljs-keyword">push</span>(x[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top() &gt; x[i]) &#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t = s.top();<br>s.<span class="hljs-keyword">pop</span>();<br><span class="hljs-keyword">count</span>++;<br>t = t * <span class="hljs-keyword">count</span>;<br>maxs = max(t, maxs);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-keyword">count</span>; j++) &#123;<br>s.<span class="hljs-keyword">push</span>(x[i]);<br>&#125;<br>&#125;<br>cout &lt;&lt; maxs;<br></code></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>如果队列为空或者队尾元素小于入队元素，则入队<br>否则，入队则会破坏队内元素的单调性，则需要将不满足条件的队尾元素全部出队后，将入队元素入队</p><p><img src="/images/cs_net/QQ截图20210618192621.png" style="zoom:67%;"></p><h4 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lisp">deque&lt;int&gt; q1<span class="hljs-comment">;</span><br>for (<span class="hljs-name">int</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; n; i++) &#123;</span><br>int jud = i - k + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>if (<span class="hljs-name">jud</span> &lt; <span class="hljs-number">0</span>)<br>jud = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>while (<span class="hljs-name">q1</span>.size() &gt; <span class="hljs-number">0</span> <span class="hljs-symbol">&amp;&amp;</span> q1.front() &lt; i - k + <span class="hljs-number">1</span>) &#123;<br>q1.pop_front()<span class="hljs-comment">;</span><br>&#125;<br>while (<span class="hljs-name">q1</span>.size() &gt; <span class="hljs-number">0</span> <span class="hljs-symbol">&amp;&amp;</span> x[q1.back()] &gt; x[i]) &#123;<br>q1.pop_back()<span class="hljs-comment">;</span><br>&#125;<br>q1.push_back(<span class="hljs-name">i</span>)<span class="hljs-comment">;</span><br>if (<span class="hljs-name">i</span> - k + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>)<br>ymin[i - k + <span class="hljs-number">1</span>] = x[q1.front()]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">bool prime(int n)<br>&#123;<br>        if（n<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>) return false<span class="hljs-comment">;</span><br>        if (n<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>) return true<span class="hljs-comment">;</span><br>for(int i<span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-comment">;i*i&lt;=n;i++)</span><br>   if (n%i<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>) return false<span class="hljs-comment">;</span><br>return true<span class="hljs-comment">; </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (a % b == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">gcd</span><span class="hljs-params">(b, a % b)</span></span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><h3 id="通用结构"><a href="#通用结构" class="headerlink" title="通用结构"></a>通用结构</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs prolog">struct matrix<br>&#123;<br>    ll x[w][w];<br>    matrix operator*(const matrix &amp;t) const<br>    &#123;<br>        matrix ret;<br>        for (int i = <span class="hljs-number">0</span>; i &lt; w; i++)<br>        &#123;<br>            for (int j = <span class="hljs-number">0</span>; j &lt; w; j++)<br>            &#123;<br>                ret.x[i][j] = <span class="hljs-number">0</span>;<br>                for (int k = <span class="hljs-number">0</span>; k &lt; w; k++)<br>                &#123;<br>                    ret.x[i][j] += x[i][k] * t.x[k][j] <span class="hljs-comment">% modx;</span><br>                    ret.x[i][j] <span class="hljs-comment">%= modx;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        return ret;<br>    &#125;<br>    matrix() &#123; memset(x, <span class="hljs-number">0</span>, sizeof(x)); &#125;<br>&#125;;<br>matrix quick_pow(matrix a, ll x)<br>&#123;<br>    matrix ret;<br>    // 此处为具体初始矩阵<br>    ret.x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = ret.x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    ret.x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = ret.x[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    while (x)<br>    &#123;<br>        if (x &amp; <span class="hljs-number">1</span>)<br>            ret = ret * a;<br>        a = a * a;<br>        x &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h3><p><img src="/images/cs_net/QQ截图20210618194539.png" style="zoom: 33%;"></p><h3 id="自然数幂和"><a href="#自然数幂和" class="headerlink" title="自然数幂和"></a>自然数幂和</h3><p><img src="/images/cs_net/QQ截图20210618194633.png" style="zoom: 50%;"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs inform7">matrix a;<br>a.x<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 1;<br>a.x<span class="hljs-comment">[w - 1]</span><span class="hljs-comment">[w - 1]</span> = 1;<br>for (int i = 1; i &lt; w; i++)<br>&#123;<br>a.x<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = calc(k, i - 1); // 第一行<br>&#125;<br>for (int i = 1; i &lt; w - 1; i++) // 剩余行，均是组合数形式<br>&#123;<br>for (int j = 0; j &lt; w; j++)<br>&#123;<br>a.x<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = calc(k - i + 1, j - i);<br>&#125;<br>&#125;<br>for (int i = 0; i &lt; w - 1; i++) // 最后一行<br>&#123;<br>a.x<span class="hljs-comment">[w - 1]</span><span class="hljs-comment">[i]</span> = 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="染色问题"><a href="#染色问题" class="headerlink" title="染色问题"></a>染色问题</h3><p>现需要用红、蓝、绿、黄四种颜色对n个连续格子染色</p><p>询问满足红色、绿色格子数量同时为偶数的染色方案</p><h5 id="A-i-表示-i-个格子，红绿均为偶数的染色方案数"><a href="#A-i-表示-i-个格子，红绿均为偶数的染色方案数" class="headerlink" title="A[i] 表示 i 个格子，红绿均为偶数的染色方案数"></a>A[i] 表示 i 个格子，红绿均为偶数的染色方案数</h5><h5 id="B-i-表示-i-个格子，红绿均为奇数的染色方案数"><a href="#B-i-表示-i-个格子，红绿均为奇数的染色方案数" class="headerlink" title="B[i] 表示 i 个格子，红绿均为奇数的染色方案数"></a>B[i] 表示 i 个格子，红绿均为奇数的染色方案数</h5><h5 id="C-i-表示-i-个格子，红绿有一个为偶数的染色方案数"><a href="#C-i-表示-i-个格子，红绿有一个为偶数的染色方案数" class="headerlink" title="C[i] 表示 i 个格子，红绿有一个为偶数的染色方案数"></a>C[i] 表示 i 个格子，红绿有一个为偶数的染色方案数</h5><p><img src="/images/cs_net/QQ截图20210618195114.png" style="zoom:50%;"></p><h3 id="喜爱度问题"><a href="#喜爱度问题" class="headerlink" title="喜爱度问题"></a>喜爱度问题</h3><p><img src="/images/cs_net/QQ截图20210618195253.png" style="zoom:50%;"></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs stata">struct <span class="hljs-keyword">matrix</span><br>&#123;<br>    ll x[w][w];<br>    <span class="hljs-keyword">matrix</span> operator*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">matrix</span> &amp;t) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">matrix</span> <span class="hljs-keyword">ret</span>;<br>        <span class="hljs-keyword">for</span> (int i = 0; i &lt; <span class="hljs-keyword">m</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (int j = 0; j &lt; <span class="hljs-keyword">m</span>; j++)<br>            &#123;<br>                <span class="hljs-keyword">ret</span>.x[i][j] = 0;<br>                <span class="hljs-keyword">for</span> (int k = 0; k &lt; <span class="hljs-keyword">m</span>; k++)<br>                &#123;<br>                    <span class="hljs-keyword">ret</span>.x[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-keyword">ret</span>.x[i][j], x[i][k] + t.x[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;<br>    &#125;<br>    <span class="hljs-built_in">matrix</span>() &#123; memset(x, 0, sizeof(x)); &#125;<br>&#125;;<br><br><span class="hljs-keyword">matrix</span> quick_pow(<span class="hljs-keyword">matrix</span> a, ll x)<br>&#123;<br>    <span class="hljs-keyword">matrix</span> <span class="hljs-keyword">ret</span>;<br>    <span class="hljs-keyword">for</span> (int i = 0; i &lt; <span class="hljs-keyword">m</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (int j = 0; j &lt; <span class="hljs-keyword">m</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == j)<br>                <span class="hljs-keyword">ret</span>.x[i][i] = 0;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">ret</span>.x[i][i] = -<span class="hljs-keyword">inf</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (x)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x &amp; 1)<br>            <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">ret</span> * a;<br>        a = a * a;<br>        x &gt;&gt;= 1;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h5 id="是求取前缀和方法的优化，本质还是前缀和，以类似二进制拆分的形式优化"><a href="#是求取前缀和方法的优化，本质还是前缀和，以类似二进制拆分的形式优化" class="headerlink" title="是求取前缀和方法的优化，本质还是前缀和，以类似二进制拆分的形式优化"></a>是求取前缀和方法的优化，本质还是前缀和，以类似二进制拆分的形式优化</h5><h5 id="不足是无法进行最值的操作"><a href="#不足是无法进行最值的操作" class="headerlink" title="不足是无法进行最值的操作"></a>不足是无法进行最值的操作</h5><p><img src="/images/cs_net/QQ截图20210619095736.png" style="zoom:67%;"></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><img src="/images/cs_net/QQ截图20210619095728.png" style="zoom:67%;"></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><img src="/images/cs_net/QQ截图20210619095841.png" style="zoom:67%;"></p><h3 id="二维偏序问题"><a href="#二维偏序问题" class="headerlink" title="二维偏序问题"></a>二维偏序问题</h3><p>先在一个维度上排序，然后进行逆序对输出</p><p>该程序的得分为<strong>运行时间</strong>与<strong>内存占用</strong>均小于等于该程序的程序的数量，求成绩为0,1,…<em>n</em>−1 的程序的数量分别为多少</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lb(x) ((x) &amp; (-x))</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= <span class="hljs-number">1000100</span>; i += <span class="hljs-built_in">lb</span>(i))<br>s[i] += v;<br>&#125;<br> <br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>ll res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &gt;= <span class="hljs-number">1</span>; i -= <span class="hljs-built_in">lb</span>(i))<br>res += s[i];<br><span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; a, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;b)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (a.first != b.first)<br><span class="hljs-keyword">return</span> a.first &lt; b.first;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> a.second &lt; b.second;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;p.first, &amp;p.second);<br>p.second++;<br>d.<span class="hljs-built_in">emplace_back</span>(p);<br>&#125;<br><span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>(), cmp);<br>ll res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>res = <span class="hljs-built_in">ask</span>(d[i].second) - <span class="hljs-built_in">ask</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">upd</span>(d[i].second, <span class="hljs-number">1</span>);<br>pos[res]++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><img src="/images/cs_net/QQ截图20210619101207.png" style="zoom:50%;"></p><p><img src="/images/cs_net/QQ截图20210619101148.png" style="zoom:50%;"></p><h3 id="线段树建立"><a href="#线段树建立" class="headerlink" title="线段树建立"></a>线段树建立</h3><p><img src="/images/cs_net/QQ截图20210619101257.png" style="zoom:67%;"></p><h3 id="线段树修改"><a href="#线段树修改" class="headerlink" title="线段树修改"></a>线段树修改</h3><p><img src="/images/cs_net/QQ截图20210619101335.png" style="zoom:67%;"></p><h3 id="线段树查询"><a href="#线段树查询" class="headerlink" title="线段树查询"></a>线段树查询</h3><p><img src="/images/cs_net/QQ截图20210619101434.png" style="zoom:67%;"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lch ((x &lt;&lt; 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rch ((x &lt;&lt; 1) | 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m ((l + r) / 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tol lch,l,m</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> tor rch,m+1,r</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>d[x] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">build</span>(tol);<br><span class="hljs-built_in">build</span>(tor);<br>d[x] = <span class="hljs-built_in">max</span>(d[lch], d[rch]);<br>&#125;<br> <br><span class="hljs-type">int</span> p, v;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>d[x] += v;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (p &lt;= m) <span class="hljs-built_in">upd</span>(tol);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">upd</span>(tor);<br>d[x] = <span class="hljs-built_in">max</span>(d[lch], d[rch]);<br>&#125;<br><br><span class="hljs-comment">// l,r为目标查询区间，p1,p2为当前查询区间</span><br><span class="hljs-comment">// 合并多个类似p1,p2的区间得到l,r</span><br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p1,<span class="hljs-type">int</span> p2)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == p1 &amp;&amp; r == p2) &#123;<br><span class="hljs-keyword">return</span> d[x];<br>&#125;<br><span class="hljs-keyword">if</span> (p2 &lt;= m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(tol, p1, p2);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1 &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(tor, p1, p2);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">ask</span>(tol, p1, m), <span class="hljs-built_in">ask</span>(tor, m + <span class="hljs-number">1</span>, p2));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cs learning</category>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Programming —— DP</title>
    <link href="/2022/03/10/program3/"/>
    <url>/2022/03/10/program3/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划dp问题"><a href="#动态规划dp问题" class="headerlink" title="动态规划dp问题"></a>动态规划dp问题</h1><h2 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h2><h3 id="爬台阶问题"><a href="#爬台阶问题" class="headerlink" title="爬台阶问题"></a>爬台阶问题</h3><p><img src="/images/cs_net/QQ截图20210618082709.png" style="zoom: 50%;"></p><h3 id="最大区间和"><a href="#最大区间和" class="headerlink" title="最大区间和"></a>最大区间和</h3><p><img src="/images/cs_net/QQ截图20210618082720.png" style="zoom: 50%;"></p><h5 id="变式：可改变一个数（仅一次）"><a href="#变式：可改变一个数（仅一次）" class="headerlink" title="变式：可改变一个数（仅一次）"></a>变式：可改变一个数（仅一次）</h5><p><img src="/images/cs_net/QQ截图20210618083041.png" style="zoom: 50%;"></p><h3 id="走地图"><a href="#走地图" class="headerlink" title="走地图"></a>走地图</h3><p><img src="/images/cs_net/QQ截图20210618083449.png" style="zoom: 50%;"></p><h3 id="取数"><a href="#取数" class="headerlink" title="取数"></a>取数</h3><p><img src="/images/cs_net/QQ截图20210618084346.png" style="zoom: 50%;"></p><h3 id="非递减字符序列"><a href="#非递减字符序列" class="headerlink" title="非递减字符序列"></a>非递减字符序列</h3><p><img src="/images/cs_net/QQ截图20210618084407.png" style="zoom: 50%;"></p><h3 id="矩阵选数"><a href="#矩阵选数" class="headerlink" title="矩阵选数"></a>矩阵选数</h3><p>给定3行n列的矩阵，的从每一列选择一个数，求出后一列减去前一列的绝对值的和的最小值</p><p><img src="/images/cs_net/QQ截图20210618084418.png" style="zoom: 50%;"></p><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><h5 id="注意——子序列不同于子串，子串必须连续，子序列可以不连续只要按顺序即可"><a href="#注意——子序列不同于子串，子串必须连续，子序列可以不连续只要按顺序即可" class="headerlink" title="注意——子序列不同于子串，子串必须连续，子序列可以不连续只要按顺序即可"></a>注意——子序列不同于子串，子串必须连续，子序列可以不连续只要按顺序即可</h5><p><img src="/images/cs_net/QQ截图20210618085033.png" style="zoom: 50%;"></p><h5 id="经过树状数组优化后的程序"><a href="#经过树状数组优化后的程序" class="headerlink" title="经过树状数组优化后的程序"></a>经过树状数组优化后的程序</h5><figure class="highlight llvm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs llvm">for (int j <span class="hljs-operator">=</span> d[<span class="hljs-number">1</span>]<span class="hljs-comment">; j &lt;= 1e6; j += (j &amp; (-j)))</span><br>    &#123;<br>        s[j] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    &#125;<br>    f[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    // 求解i之前，所有小于Ai的元素的f[j]的最大值<br>    for (int i <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">; i &lt;= n; i++)</span><br>    &#123;<br>        int res <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        for (int <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> d[i] - <span class="hljs-number">1</span><span class="hljs-comment">; x &gt;= 1; x -= (x &amp; (-x)))  //查找最大值</span><br>            res <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(res<span class="hljs-punctuation">,</span> s[<span class="hljs-keyword">x</span>])<span class="hljs-comment">;</span><br>        f[i] <span class="hljs-operator">=</span> res + <span class="hljs-number">1</span><span class="hljs-comment">; // 更新fi</span><br>        for (int <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> d[i]<span class="hljs-comment">; x &lt;= 1e6; x += (x &amp; (-x))) // 更新树状数组</span><br>            s[<span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(f[i]<span class="hljs-punctuation">,</span> s[<span class="hljs-keyword">x</span>])<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><img src="/images/cs_net/QQ截图20210618085148.png" style="zoom: 50%;"></p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>有N件物品和一个容量为V的包，第i件物品体积是Wi，价值是Vi，求解将哪些物品装入包可使这些物品的体积总和不超过背包容量，且总价值最大。</p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="每种物品仅有一件，可以选择放或不放——对应1或0"><a href="#每种物品仅有一件，可以选择放或不放——对应1或0" class="headerlink" title="每种物品仅有一件，可以选择放或不放——对应1或0"></a>每种物品仅有一件，可以选择放或不放——对应1或0</h4><p><img src="/images/cs_net/QQ截图20210618090129.png" style="zoom:50%;"></p><h4 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h4><p>前后两个状态，两维优化，必须<strong>逆序遍历</strong></p><p>如果是顺序的话则会出现同一件物品选多次的情况</p><p><img src="/images/cs_net/QQ截图20210618090502.png" style="zoom:50%;"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for (int i = 1; i &lt;= n; ++i)<br>    &#123;<br>        for (int j = v; j &gt;= 0; --j)<br>        &#123;<br>            if (j - w<span class="hljs-comment">[i]</span> &gt;= 0)<br>                f<span class="hljs-comment">[j]</span> = max(f<span class="hljs-comment">[j]</span>, f<span class="hljs-comment">[j - w<span class="hljs-comment">[i]</span>]</span> + c<span class="hljs-comment">[i]</span>);<br>        &#125;<br>    &#125;<br>    ans = f<span class="hljs-comment">[v]</span>;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>每种物品有无数件，可以选择0或多件</p><p>按照最优的原则可以选无数件，可好需要01背包中的<strong>正序遍历</strong></p><p><img src="/images/cs_net/QQ截图20210618090815.png" style="zoom:50%;"></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>每个物品有限件，指定可放入的件数</p><h5 id="二进制拆分，用尽可能少的组数覆盖所有的决策"><a href="#二进制拆分，用尽可能少的组数覆盖所有的决策" class="headerlink" title="二进制拆分，用尽可能少的组数覆盖所有的决策"></a>二进制拆分，用尽可能少的组数覆盖所有的决策</h5><p>取出小于2的n-1次的幂数，1,2,4……，剩余的直接作为一组，重量和价值改为对应倍数，再使用01背包</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for (int i = 1; i &lt;= n; i++) //二进制分解，使用二进制数来组合出所有可能<br>    &#123;<br>        int t = s<span class="hljs-comment">[i]</span>;<br>        for (int k = 1; k &lt;= t; k &lt;&lt;= 1) //取出小于2的n-1次的幂数，1,2,4……，重量和价值改为对应倍数<br>        &#123;<br>            cnt++;<br>            vv<span class="hljs-comment">[cnt]</span> = k * c<span class="hljs-comment">[i]</span>;<br>            ww<span class="hljs-comment">[cnt]</span> = k * w<span class="hljs-comment">[i]</span>;<br>            t -= k;<br>        &#125;<br>        if (t &gt; 0) //剩余的数 直接保留不再分解 1,2 4,8,5，重量和价值改为对应倍数<br>        &#123;<br>            cnt++;<br>            vv<span class="hljs-comment">[cnt]</span> = t * c<span class="hljs-comment">[i]</span>;<br>            ww<span class="hljs-comment">[cnt]</span> = t * w<span class="hljs-comment">[i]</span>;<br>        &#125;<br>    &#125;<br>    for (int i = 1; i &lt;= cnt; ++i)<br>    &#123;<br>        for (int j = v; j &gt;= 0; --j) // 对于更新后的进行01背包即可<br>        &#123;<br>            if (j - ww<span class="hljs-comment">[i]</span> &gt;= 0)<br>                f<span class="hljs-comment">[j]</span> = max(f<span class="hljs-comment">[j]</span>, f<span class="hljs-comment">[j - ww<span class="hljs-comment">[i]</span>]</span> + vv<span class="hljs-comment">[i]</span>);<br>        &#125;<br>    &#125;<br>    ans = f<span class="hljs-comment">[v]</span>;<br></code></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>每种物品有1件，物品归属于共n个组，每组只能选1件</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">用w<span class="hljs-comment">[k]</span><span class="hljs-comment">[u]</span>和v<span class="hljs-comment">[k]</span><span class="hljs-comment">[u]</span>分别表示第k组的第u件物品的属性值<br>t<span class="hljs-comment">[k]</span><span class="hljs-comment">[cnt<span class="hljs-comment">[k]</span>]</span> = i; // 记录第几组第几个物品<br><br>for (int k = 1; k &lt;= ts; k++)             // 循环每一组<br>        for (int i = v; i &gt;= 0; --i)          // 循环容量<br>            for (int j = 1; j &lt;= cnt<span class="hljs-comment">[k]</span>; ++j) // 循环每组内的每个物品<br>                if (i - w<span class="hljs-comment">[t<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>]</span> &gt;= 0)<br>                    f<span class="hljs-comment">[i]</span> = max(f<span class="hljs-comment">[i]</span>, f<span class="hljs-comment">[i - w<span class="hljs-comment">[t<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>]</span>]</span> + c<span class="hljs-comment">[t<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>]</span>); // 取或不取<br>ans = f<span class="hljs-comment">[v]</span>;<br></code></pre></td></tr></table></figure><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p><img src="/images/cs_net/QQ截图20210618093032.png" style="zoom:50%;"></p><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p><img src="/images/cs_net/QQ截图20210618093225.png" style="zoom:50%;"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = <span class="hljs-number">2</span>; <span class="hljs-built_in">len</span> &lt;= <span class="hljs-built_in">n</span>; <span class="hljs-built_in">len</span>++)<br>    &#123;<br>        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * <span class="hljs-built_in">n</span> - <span class="hljs-built_in">len</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">int</span> l = i;<br>            <span class="hljs-built_in">int</span> r = i + <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> ans1 = maxn;<br>            <span class="hljs-built_in">int</span> ans2 = minn;<br>            for (<span class="hljs-built_in">int</span> k = l; k &lt; r; k++)<br>            &#123;<br>                ans1 = <span class="hljs-built_in">min</span>(ans1, <span class="hljs-symbol">f1</span>[l][k] + <span class="hljs-symbol">f1</span>[k + <span class="hljs-number">1</span>][r]);<br>                ans2 = <span class="hljs-built_in">max</span>(ans2, <span class="hljs-symbol">f2</span>[l][k] + <span class="hljs-symbol">f2</span>[k + <span class="hljs-number">1</span>][r]);<br>            &#125;<br>            <span class="hljs-symbol">f1</span>[l][r] = ans1 + <span class="hljs-built_in">sum</span>[r] - <span class="hljs-built_in">sum</span>[l - <span class="hljs-number">1</span>];<br>            <span class="hljs-symbol">f2</span>[l][r] = ans2 + <span class="hljs-built_in">sum</span>[r] - <span class="hljs-built_in">sum</span>[l - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h3><p><img src="/images/cs_net/QQ截图20210618093606.png" style="zoom:50%;"></p><p><img src="/images/cs_net/QQ截图20210618093726.png" style="zoom:50%;"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs prolog">for (int i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        f1[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>for (int len = <span class="hljs-number">2</span>; len &lt;= n; len++)<br>    &#123;<br>        for (int i = <span class="hljs-number">0</span>; i &lt; n - len + <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            int l = i;<br>            int r = i + len - <span class="hljs-number">1</span>;<br>            int ans1 = maxn;<br>            for (int k = l; k &lt; r; k++)<br>            &#123;<br>                ans1 = min(ans1, f1[l][k] + f1[k + <span class="hljs-number">1</span>][r]);<br>            &#125;<br>            if ((s[l] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; s[r] == <span class="hljs-string">&#x27;)&#x27;</span>) || (s[l] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; s[r] == <span class="hljs-string">&#x27;]&#x27;</span>)) <br>            // 括号成对出现，不需要另外添加，等于除去这两个以后需要的个数<br>                f1[l][r] = f1[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>];<br>            else<br>                f1[l][r] = ans1;<br>            f1[l][r] = min(ans1, f1[l][r]);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最长回文问题"><a href="#最长回文问题" class="headerlink" title="最长回文问题"></a>最长回文问题</h3><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><p><img src="/images/cs_net/QQ截图20210618094136.png" style="zoom:50%;"></p><h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><p><img src="/images/cs_net/QQ截图20210618094301.png" style="zoom:50%;"></p><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 查询状态S中是否有编号为i的点</span><br><span class="hljs-keyword">if</span> (s &amp; (<span class="hljs-number">1</span> &lt;&lt; i))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">// 在状态S中添加编号为i的点</span><br>s = s | (<span class="hljs-number">1</span> &lt;&lt; i);<br><br><span class="hljs-comment">// 在状态S中删除编号为i的点</span><br><span class="hljs-keyword">if</span> (s &amp; (<span class="hljs-number">1</span> &lt;&lt; i))<br>    s = s ^ (<span class="hljs-number">1</span> &lt;&lt; i);<br></code></pre></td></tr></table></figure><h3 id="棋盘分割"><a href="#棋盘分割" class="headerlink" title="棋盘分割"></a>棋盘分割</h3><p>根据格子是否会向下延伸，对其用0 1分别表示<br>平躺的长方形 / 竖直长方形的下半部分，即为0，竖直长方形的上半部分，即为1<br>f矩阵表示填充到了第 i 行，第 i 行填充状态为S的方案数</p><p><img src="/images/cs_net/QQ截图20210618095341.png" style="zoom:50%;"></p><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void dfs(int x, int fa)<br>&#123;<br>    bool isleaf = 1;<br>    for (int i = head<span class="hljs-comment">[x]</span>; i != -1; i = e<span class="hljs-comment">[i]</span>.next)<br>    &#123;<br>        int y = e<span class="hljs-comment">[i]</span>.v;<br>        if (y != fa)<br>        &#123; //不是叶子节点<br>            isleaf = 0;<br>            dfs(y, x); //已经求出了所有y的信息<br>            if (ans &lt; deep<span class="hljs-comment">[x]</span> + deep<span class="hljs-comment">[y]</span> + 1)<br>            &#123;<br>                ans = deep<span class="hljs-comment">[x]</span> + deep<span class="hljs-comment">[y]</span> + 1;<br>                cnt = dp<span class="hljs-comment">[x]</span> * dp<span class="hljs-comment">[y]</span>; // 乘法原理 方案数<br>            &#125;<br>            else if (ans == deep<span class="hljs-comment">[x]</span> + deep<span class="hljs-comment">[y]</span> + 1)<br>            &#123;<br>                cnt += dp<span class="hljs-comment">[x]</span> * dp<span class="hljs-comment">[y]</span>;<br>            &#125;<br>            if (deep<span class="hljs-comment">[y]</span> + 1 &gt; deep<span class="hljs-comment">[x]</span>)<br>            &#123;<br>                deep<span class="hljs-comment">[x]</span> = deep<span class="hljs-comment">[y]</span> + 1;<br>                dp<span class="hljs-comment">[x]</span> = dp<span class="hljs-comment">[y]</span>;<br>            &#125;<br>            else if (deep<span class="hljs-comment">[y]</span> + 1 == deep<span class="hljs-comment">[x]</span>)<br>            &#123;<br>                dp<span class="hljs-comment">[x]</span> += dp<span class="hljs-comment">[y]</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    if (isleaf)<br>    &#123; //是叶子节点<br>        deep<span class="hljs-comment">[x]</span> = 0;<br>        dp<span class="hljs-comment">[x]</span> = 1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h3><p>子节点和其父节点不能同时参与</p><p><img src="/images/cs_net/QQ截图20210618151446.png" style="zoom:50%;"></p><p>状态转移方程</p><p><img src="/images/cs_net/QQ截图20210618151521.png" style="zoom:50%;"></p><h3 id="多重背包（非二进制）"><a href="#多重背包（非二进制）" class="headerlink" title="多重背包（非二进制）"></a>多重背包（非二进制）</h3><p><img src="/images/cs_net/QQ截图20210618152329.png" style="zoom: 67%;"></p><p><img src="/images/cs_net/QQ截图20210618152329.png" style="zoom: 67%;"></p><h2 id="dp优化"><a href="#dp优化" class="headerlink" title="dp优化"></a>dp优化</h2><h3 id="前缀和优化（帝国大厦）"><a href="#前缀和优化（帝国大厦）" class="headerlink" title="前缀和优化（帝国大厦）"></a>前缀和优化（帝国大厦）</h3><p><img src="/images/cs_net/QQ截图20210618152747.png" style="zoom:50%;"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for (int i = 1; i &lt;= k; i++)<br>    &#123;<br>        for (int j = 1; j &lt;= n; j++)<br>        &#123;<br>            int bound;<br>            if (j &gt; b) // 拆除绝对值后分类讨论<br>            &#123;<br>                bound = j - (j - b - 1) / 2;  // 确定满足条件的边界值<br>                // 当j&gt;b时，x只要大于bound 均可以到达<br>                dp<span class="hljs-comment">[i % 2]</span><span class="hljs-comment">[j]</span> = ((sum<span class="hljs-comment">[(i + 1) % 2]</span><span class="hljs-comment">[n]</span> - sum<span class="hljs-comment">[(i + 1) % 2]</span><span class="hljs-comment">[bound - 1]</span> - dp<span class="hljs-comment">[(i + 1) % 2]</span><span class="hljs-comment">[j]</span>) % modx + modx) % modx;<br>            &#125;<br>            if (j &lt; b)<br>            &#123;<br>                bound = j + (b - j - 1) / 2;  // 确定满足条件的边界值<br>                // 当j&lt;b时，只要x小于bound 均可以到达<br>                dp<span class="hljs-comment">[i % 2]</span><span class="hljs-comment">[j]</span> = ((sum<span class="hljs-comment">[(i + 1) % 2]</span><span class="hljs-comment">[bound]</span> - dp<span class="hljs-comment">[(i + 1) % 2]</span><span class="hljs-comment">[j]</span>) % modx + modx) % modx;<br>            &#125;<br>            sum<span class="hljs-comment">[i % 2]</span><span class="hljs-comment">[j]</span> = (sum<span class="hljs-comment">[i % 2]</span><span class="hljs-comment">[j - 1]</span> + dp<span class="hljs-comment">[i % 2]</span><span class="hljs-comment">[j]</span>) % modx;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="单调队列优化（最大区间和）"><a href="#单调队列优化（最大区间和）" class="headerlink" title="单调队列优化（最大区间和）"></a>单调队列优化（最大区间和）</h3><p>找出不超过m的连续子区间，使其序列和最大</p><p><img src="/images/cs_net/QQ截图20210618152910.png" style="zoom:50%;"></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lisp">for (<span class="hljs-name">int</span> i = <span class="hljs-number">1</span><span class="hljs-comment">; i &lt;= n; i++)</span><br>    &#123;<br>        while (!q.empty() <span class="hljs-symbol">&amp;&amp;</span> sum[q.back()] &gt; sum[i])  // 找出sum[k]的最小<br>            q.pop_back()<span class="hljs-comment">;</span><br>        q.push_back(<span class="hljs-name">i</span>)<span class="hljs-comment">;</span><br>        while (!q.empty() <span class="hljs-symbol">&amp;&amp;</span> i - m &gt; q.front())  // 弹出超出m范围限制的<br>            q.pop_front()<span class="hljs-comment">;</span><br>        ans = max(<span class="hljs-name">ans</span>, sum[i] - sum[q.front()])<span class="hljs-comment">;  // 更新结果</span><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cs learning</category>
      
      <category>programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data security</title>
    <link href="/2022/03/10/Data-security/"/>
    <url>/2022/03/10/Data-security/</url>
    
    <content type="html"><![CDATA[<h1 id="一、大数据与大数据安全"><a href="#一、大数据与大数据安全" class="headerlink" title="一、大数据与大数据安全"></a>一、大数据与大数据安全</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h3><p>​        大数据是指无法在一定时间范围内使用常规软件工具进行<strong>捕捉、管理和处理</strong>的<strong>数据集合</strong></p><h4 id="特点：5V"><a href="#特点：5V" class="headerlink" title="特点：5V"></a>特点：5V</h4><p>​        volume 规模大、velocity 变化快、variety 种类多、value 价值密度低、Veracity 数据准确性和质量不高</p><h2 id="大数据安全的内涵"><a href="#大数据安全的内涵" class="headerlink" title="大数据安全的内涵"></a>大数据安全的内涵</h2><h3 id="保障大数据安全"><a href="#保障大数据安全" class="headerlink" title="保障大数据安全"></a>保障大数据安全</h3><p>​        保障大数据采集过程、计算过程、数据形态、应用价值</p><h3 id="大数据用于安全"><a href="#大数据用于安全" class="headerlink" title="大数据用于安全"></a>大数据用于安全</h3><p>​        利用大大数据技术提升信息系统安全效能的能力和方法，涉及如何解决信息系统安全的问题</p><h2 id="大数据安全保障（威胁）"><a href="#大数据安全保障（威胁）" class="headerlink" title="大数据安全保障（威胁）"></a>大数据安全保障（威胁）</h2><h3 id="大数据基础设施既有虚拟化和分布式的特点，易受到各类攻击"><a href="#大数据基础设施既有虚拟化和分布式的特点，易受到各类攻击" class="headerlink" title="大数据基础设施既有虚拟化和分布式的特点，易受到各类攻击"></a>大数据基础设施既有虚拟化和分布式的特点，易受到各类攻击</h3><p>​        非授权访问、信息泄露或丢失、破坏数据完整性、网络病毒传播</p><h3 id="数据存储环节中，非关系型数据库易受安全挑战"><a href="#数据存储环节中，非关系型数据库易受安全挑战" class="headerlink" title="数据存储环节中，非关系型数据库易受安全挑战"></a>数据存储环节中，非关系型数据库易受安全挑战</h3><p>​        模式成熟度不够、关系成熟度不够、服务器软件没有足够的安全机制</p><h3 id="网络安全问题"><a href="#网络安全问题" class="headerlink" title="网络安全问题"></a>网络安全问题</h3><p>​        安全数据规模巨大、安全事态难以感知</p><h3 id="网络化社会使得大数据易成为攻击目标"><a href="#网络化社会使得大数据易成为攻击目标" class="headerlink" title="网络化社会使得大数据易成为攻击目标"></a>网络化社会使得大数据易成为攻击目标</h3><h3 id="大数据滥用的风险"><a href="#大数据滥用的风险" class="headerlink" title="大数据滥用的风险"></a>大数据滥用的风险</h3><p>​        大数据本身存在漏洞、攻击者使用大数据技术进行攻击以收集用户信息</p><h3 id="大数据误用风险"><a href="#大数据误用风险" class="headerlink" title="大数据误用风险"></a>大数据误用风险</h3><p>​        数据准确性和质量不高，对于分析可能产生无效结果</p><h2 id="保障大数据安全-1"><a href="#保障大数据安全-1" class="headerlink" title="保障大数据安全"></a>保障大数据安全</h2><h3 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h3><p>​        威胁：数据损坏、丢失、泄露、窃取</p><p>​        安全机制：身份认证、数据加密、完整性保护、抗重放攻击、端到端的数据安全传输</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>​        威胁：数据被窃取、丢失、破坏、机密数据泄露、隐私数据泄露</p><p>​        安全机制：隐私保护    数据变换、匿名化；数据加密    静态数据线加密在存储，动态数据同态加密；备份与恢复</p><h3 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h3><p>​        概念：从海量数据中自动抽取隐藏在数据中有用信息的过程</p><p>​        威胁：第三方在数据挖掘过程中植入恶意程序、窃取系统数据</p><p>​        安全机制：身份认证、访问控制    自住访问控制DAC、强制访问控制MAC、基于角色的访问控制RBAC</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>​        概念：向数据实体输出挖掘结果的环节</p><p>​        威胁：泄密、泄露隐私、不合规范</p><p>​        安全机制：安全审计、数据溯源    在大数据应用周期的各个环节对操作进行标记和定位</p><h2 id="大数据用于安全-1"><a href="#大数据用于安全-1" class="headerlink" title="大数据用于安全"></a>大数据用于安全</h2><p>​        利用大数据实时监控海量的数据，有效提高安全监测的能力</p><p>​        把传统的数据安全分析的<strong>被动的事后分析</strong>变成<strong>主动的事前防御</strong></p><p>​        设计具备实时监测能力与事后回溯能力的全流量审计方案</p><h2 id="隐私安全"><a href="#隐私安全" class="headerlink" title="隐私安全"></a>隐私安全</h2><h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h3><p>​        概念：隐私是与个人相关的、具有不被他人搜集、保留和出分的权力的信息资料集合，并且它能够按照所有者的意愿在特定时间、以特定方式、在特定程度上被公开</p><p>​        基本属性：保密性、个人相关、能够被所有者处分</p><h3 id="隐私保护的客体"><a href="#隐私保护的客体" class="headerlink" title="隐私保护的客体"></a>隐私保护的客体</h3><p>​        个人属性的隐私权、个人资料的隐私权、通信内容的隐私权、匿名的隐私权</p><h3 id="隐私保护的威胁"><a href="#隐私保护的威胁" class="headerlink" title="隐私保护的威胁"></a>隐私保护的威胁</h3><p>​        数据搜集、信息服务、搜索引擎、数据挖掘</p><h3 id="隐私保护的大数据威胁"><a href="#隐私保护的大数据威胁" class="headerlink" title="隐私保护的大数据威胁"></a>隐私保护的大数据威胁</h3><p>​        信息存储和管理的集中化，一切皆可量化</p><p>​        大数据局通常包含了大量的用户身份信息、属性信息</p><p>​        大数据的多源性，各个渠道的数据可以进行交叉检验</p><p>​        存储过程：用户对个人数据的采用、存储、使用和分享无法有效控制</p><p>​        传输过程：传统物理方法无法有效保证数据的长距离传输的安全性</p><p>​        处理过程：访问控制和身份认证的管理难度增加，基础设施的脆弱性和加密措施的失效可能产生新的安全风险</p><h1 id="二、物联网"><a href="#二、物联网" class="headerlink" title="二、物联网"></a>二、物联网</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>​        物联网是基于互联网、传统电信网等信息承载体，让所有<strong>能够寻址的物理实体实现互联互通</strong>，从而实现某种特定的<strong>功能业务</strong>的网络</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​        联网终端规模化、异构设备互联化、感知控制普适化、管理调度智能化、应用服务链条化、经济发展跨越化</p><h3 id="与互联网的异同"><a href="#与互联网的异同" class="headerlink" title="与互联网的异同"></a>与互联网的异同</h3><p>​        基础技术相同：都是建立在分组技术之上，采用分组交换网作为承载网，物联网的重要基础和核心仍然是互联网</p><p>​        涵盖范围不同：互联网让人与人交换信息；物联网让物与物交换信息，从而间接为人服务</p><p>​        终端接入方式不同：互联网通过接入网络将设备接入，以太网、宽带、WiFi、5G等；物联网节点需要通过末端网络接入到网络汇聚点，然后连接至互联网，蓝牙、ZigBee等</p><p>​        技术范围不同：互联网是物联网的一个技术方向；物联网几乎涵盖了信息系统的所有领域</p><h2 id="物联网架构"><a href="#物联网架构" class="headerlink" title="物联网架构"></a>物联网架构</h2><h3 id="”应用层—网络层—感知层“-架构"><a href="#”应用层—网络层—感知层“-架构" class="headerlink" title="”应用层—网络层—感知层“ 架构"></a>”应用层—网络层—感知层“ 架构</h3><p><img src="/images/data_sec/image-20211208105637994.png" alt="image-20211208105637994" style="zoom:50%;"></p><p>​        应用层：应用基础设施、中间件、和各种<strong>物联网应用</strong></p><p>​        网络层：主要是实现<strong>信息的传递、路由和控制</strong></p><p>​        感知层：实现对物理世界的智能感知识别、信息采集处理和自动控制，通过通信模块<strong>将物理实体连接到网络层和应用层</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">层级</th><th style="text-align:center">技术</th></tr></thead><tbody><tr><td style="text-align:center">应用层技术</td><td style="text-align:center">云计算、人工智能、数据挖掘、物联网中间件</td></tr><tr><td style="text-align:center">网络层技术</td><td style="text-align:center">Internet、移动电话网络、广电网络、NGB广域网络</td></tr><tr><td style="text-align:center">感知层技术</td><td style="text-align:center">传感器技术、射频识别（RFID）技术、GPS技术、二维码技术、蓝牙技术等</td></tr></tbody></table></div><h3 id="“云—管—边—端”架构"><a href="#“云—管—边—端”架构" class="headerlink" title="“云—管—边—端”架构"></a>“云—管—边—端”架构</h3><p><img src="/images/data_sec/image-20211208105619231.png" alt="image-20211208105619231" style="zoom:50%;"></p><h4 id="云"><a href="#云" class="headerlink" title="云"></a>云</h4><p>​        物联网业务的载体，基于人工智能、大数据等技术，通过信息智能处理，实现了多样化<strong>业务</strong>。</p><p>​        云服务主要有以下三类：<strong>软件即服务</strong>(SaaS) 、<strong>平台即服务</strong>(PaaS)和<strong>基础架构即服务</strong>(IaaS)。</p><h4 id="管"><a href="#管" class="headerlink" title="管"></a>管</h4><p>​        主要功能是<strong>接入网络和数据传输协议</strong>，负责终端节点间、终端节点与边缘节点、边缘节点与云之间数据的传输和控制指令的下发</p><p>​        数据通信协议分为：有线通信协议和无线通信协议</p><h4 id="边"><a href="#边" class="headerlink" title="边"></a>边</h4><p>​        部署在靠近终端设备的边缘节点，就近提供服务，终端设备的部分数据可以直接在边缘节点进行处理，无需传回云端计算</p><p>​        特点：分布式和低延时、高效率、智能化</p><h4 id="端"><a href="#端" class="headerlink" title="端"></a>端</h4><p>​        物联网感知物理世界的接口，由种类繁多的海量智能设备构成，呈现出<strong>异构化</strong>的特点，是执行感控的主体。</p><h2 id="物联网关键技术"><a href="#物联网关键技术" class="headerlink" title="物联网关键技术"></a>物联网关键技术</h2><h3 id="传感器技术"><a href="#传感器技术" class="headerlink" title="传感器技术"></a>传感器技术</h3><p>​        物联网感知世界的借口，将多元物理量转化为电信号</p><h3 id="通信技术"><a href="#通信技术" class="headerlink" title="通信技术"></a>通信技术</h3><p>​        分为有线通信与无线通信</p><p>​        有线通信<strong>可靠性高</strong>但部署条件受限，无线通信<strong>部署灵活</strong>但有更高的误码率和丢包率</p><h3 id="无线接入技术（RIT）"><a href="#无线接入技术（RIT）" class="headerlink" title="无线接入技术（RIT）"></a>无线接入技术（RIT）</h3><p>​        通过无线介质将用户终端和网络节点连接起来，已实现用户网络之间的信息传递</p><p>​        分为<strong>固定接入技术</strong>和<strong>移动接入技术</strong></p><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>​        物联网将数据上传到云端，借助云端丰富的计算和存储资源进行数据、控制指令的处理</p><p>​        云计算的<strong>数据传输成本较高，难以满足边缘业务的实时性需求</strong>，一些敏感业务的隐私数据上传也存在着<strong>安全隐私风险</strong></p><h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>​        边缘节点就近提供端服务，<strong>分布式计算</strong>思想，满足<strong>实时性较高</strong>的业务需求</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><h2 id="定位系统"><a href="#定位系统" class="headerlink" title="定位系统"></a>定位系统</h2><h3 id="卫星定位系统"><a href="#卫星定位系统" class="headerlink" title="卫星定位系统"></a>卫星定位系统</h3><p>​        美国：GPS，俄罗斯：GLONASS，欧盟：伽利略，中国：北斗一号（区域）、北斗二号（全球）</p><p>​        GPS<strong>三点定位法</strong>：宇宙空间（6个轨道平面、每个4颗卫星）、地面监测、用户设备</p><p>​        优点：精度高、全球覆盖</p><p>​        缺点：启动时间长（长时间搜索卫星）、室内信号差、需要接收机</p><h3 id="蜂窝基站定位"><a href="#蜂窝基站定位" class="headerlink" title="蜂窝基站定位"></a>蜂窝基站定位</h3><p>​        通讯区域被分割成蜂窝小区，每个小区对应一个通讯基站，通讯设备连接小区对应基站进行通讯</p><p><img src="/images/data_sec/image-20211208105530360.png" alt="image-20211208105530360" style="zoom:50%;"></p><p>​        优点：启动速度快、不需要接收机、信号穿透能力强</p><p>​        缺点：定位精度相对较低、基站硬件需求较高、造价昂贵</p><p>​        典型例子：紧急电话定位（报警、救护）</p><h3 id="A-GPS定位"><a href="#A-GPS定位" class="headerlink" title="A-GPS定位"></a>A-GPS定位</h3><p>​        利用基站定位确定大致范围，连接网络查询当前位置可见卫星，大大缩短搜索卫星的时间</p><h3 id="室内精确定位"><a href="#室内精确定位" class="headerlink" title="室内精确定位"></a>室内精确定位</h3><p>​        利用已有设备与网络：Wi-Fi，ZigBee，蓝牙。部署方便、成本低、精度有限</p><p>​        利用专门设备与网络：红外线、超声波、RFID、超宽带(UWB)等。精度高、部署成本高</p><p>​        优点：结构简单、成本低、</p><p>​        缺点：距离短、室内环境复杂</p><h2 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h2><h3 id="基于距离（时间）的定位（Time-of-Arrival-ToA）"><a href="#基于距离（时间）的定位（Time-of-Arrival-ToA）" class="headerlink" title="基于距离（时间）的定位（Time of Arrival, ToA）"></a>基于距离（时间）的定位（Time of Arrival, ToA）</h3><p>​        根据声波的传播时间来测量节点间的距离。</p><p>​        缺点：传播速度容易受到大气条件的影响，节点之间要求保持精确的时间同步</p><h3 id="基于距离（时间）差的定位（Time-Difference-of-Arrival-TDoA）"><a href="#基于距离（时间）差的定位（Time-Difference-of-Arrival-TDoA）" class="headerlink" title="基于距离（时间）差的定位（Time Difference of Arrival, TDoA）"></a>基于距离（时间）差的定位（Time Difference of Arrival, TDoA）</h3><p><img src="/images/data_sec/image-20211208111608440.png" alt="image-20211208111608440" style="zoom:50%;"></p><p>​        发射节点和接收节点同时发射两种不同传播速度的无线信号，接收节点根据两种信号到达的时间差及已知这两种信号的传播速度，计算两节点之间的距离。</p><p>​        缺点：对硬件要求高</p><h3 id="基于信号特征的定位（Received-Signal-Strength-RSS）"><a href="#基于信号特征的定位（Received-Signal-Strength-RSS）" class="headerlink" title="基于信号特征的定位（Received Signal Strength, RSS）"></a>基于信号特征的定位（Received Signal Strength, RSS）</h3><p>​        发射信号强度已知，用户节点定期发射信号分组，各基站根据接收到的信号强度计算传播损耗。</p><h2 id="物联网的应用场景"><a href="#物联网的应用场景" class="headerlink" title="物联网的应用场景"></a>物联网的应用场景</h2><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p>​        能源产业、公共交通、环境监测、数字城市等国家基础设施建设</p><h3 id="产业应用"><a href="#产业应用" class="headerlink" title="产业应用"></a>产业应用</h3><p>​        工业、农业等领域的应用，具体包括智能制造、智慧农业等</p><h3 id="商业服务"><a href="#商业服务" class="headerlink" title="商业服务"></a>商业服务</h3><p>​        电子货架、无人超市、智能商场等<strong>新型消费购物体验</strong>都离不开物联网提供服务</p><h3 id="消费电子"><a href="#消费电子" class="headerlink" title="消费电子"></a>消费电子</h3><p>​        智能电视、智能冰箱、智能音箱等<strong>智能化消费级电子产品</strong>逐渐兴起</p><p>​        主要应用包括智能家居、健康监测、安全监控等</p><h1 id="三、密码学"><a href="#三、密码学" class="headerlink" title="三、密码学"></a>三、密码学</h1><p><img src="/images/data_sec/image-20211208155346511.png" alt="image-20211208155346511" style="zoom:67%;"></p><h2 id="密码学发展"><a href="#密码学发展" class="headerlink" title="密码学发展"></a>密码学发展</h2><h3 id="古典密码阶段（1949之前）"><a href="#古典密码阶段（1949之前）" class="headerlink" title="古典密码阶段（1949之前）"></a>古典密码阶段（1949之前）</h3><p>​        密码还不是科学，出现密码设计的基本手段：代替法和置换法</p><p>​        保密性：基于<strong>加密算法</strong>的保密</p><h3 id="现代密码I阶段（1949-1976）"><a href="#现代密码I阶段（1949-1976）" class="headerlink" title="现代密码I阶段（1949-1976）"></a>现代密码I阶段（1949-1976）</h3><p>​        密码由艺术展变为科学</p><p>​        保密性：数据的安全<strong>基于密钥</strong>而不是算法的保密</p><p>​        香农定义了理论安全性，提出扩散与混淆</p><p>​        <strong>扩散</strong>：将每一位明文尽可能地散布到多个输出密文中去，以更隐蔽明文数字的统计特性 </p><p>​        <strong>混淆</strong>：使密文的统计特性与明文密钥之间的关系尽量复杂化</p><h3 id="现代密码学II阶段（1976-1994）"><a href="#现代密码学II阶段（1976-1994）" class="headerlink" title="现代密码学II阶段（1976-1994）"></a>现代密码学II阶段（1976-1994）</h3><p>​        <strong>公钥</strong>开始出现，Diffie&amp;Hellman提出公钥</p><h2 id="信息安全的目标"><a href="#信息安全的目标" class="headerlink" title="信息安全的目标"></a>信息安全的目标</h2><h3 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h3><p>​        保证信息/数据不会被<strong>泄露</strong>给未经授权的个体</p><p>​        攻击者无法解析消息，防御方法：<strong>加密解密算法</strong></p><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>​        保证信息/数据不会被未经授权的个体<strong>修改</strong></p><p>​        保证发送方的信息没有被篡改，防御方法：<strong>Hash 函数</strong>，纠错码，<strong>消息认证码</strong></p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>​        保证信息/数据能够被已授权的个体访问</p><p>​        破坏可用性的攻击：Denial of Service (Dos), Distributed Dos (DDoS)</p><h3 id="真实性"><a href="#真实性" class="headerlink" title="真实性"></a>真实性</h3><p>​        保证信息/数据确实来自其所声称的消息源，能够识别/实体认证及确定数据来源</p><p>​        防御工具：密码方案、<strong>数字签名</strong>、Hash函数、消息认证码、质询-响应协议</p><h3 id="不可抵赖性"><a href="#不可抵赖性" class="headerlink" title="不可抵赖性"></a>不可抵赖性</h3><p>​        保证信息/数据交互的所有参与者均不能否认曾经发送过的消息和数据</p><p>​        防御方法：数字签名</p><h2 id="密码分析学"><a href="#密码分析学" class="headerlink" title="密码分析学"></a>密码分析学</h2><p><img src="/images/data_sec/QQ截图20211208145941.png" style="zoom:67%;"></p><h3 id="密码学攻击的分类"><a href="#密码学攻击的分类" class="headerlink" title="密码学攻击的分类"></a>密码学攻击的分类</h3><p>目的是获取<strong>密钥和加解密算法</strong>，以下的方法攻击难度逐级递减</p><h3 id="唯密文攻击"><a href="#唯密文攻击" class="headerlink" title="唯密文攻击"></a>唯密文攻击</h3><p>​        攻击者有一个或多个密文，共计需要进行系统分析</p><h3 id="已知明文攻击"><a href="#已知明文攻击" class="headerlink" title="已知明文攻击"></a>已知明文攻击</h3><p>​        攻击者有一份密文和对应的明文，进行算法和密钥推导</p><h3 id="选择明文攻击"><a href="#选择明文攻击" class="headerlink" title="选择明文攻击"></a>选择明文攻击</h3><p>​        攻击者有机会使用加密机，因此可以选择任何明文并产生对应的密文，攻击概率更大</p><h3 id="选择密文攻击"><a href="#选择密文攻击" class="headerlink" title="选择密文攻击"></a>选择密文攻击</h3><p>​        攻击者有机会使用解密机，因此可以选择一些密文并产生对应的明文</p><h1 id="四、古典密码学"><a href="#四、古典密码学" class="headerlink" title="四、古典密码学"></a>四、古典密码学</h1><h2 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h2><p>建立英文字母和模26的剩余之间的对应关系</p><div class="table-container"><table><thead><tr><th style="text-align:center">word</th><th style="text-align:center">Number</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Y</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">25</td></tr></tbody></table></div><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>​        <strong>k对应加密密钥</strong></p><script type="math/tex; mode=display">y = x + k  \ (mod\ 26)</script><h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><script type="math/tex; mode=display">x = y - k\   (mod \ 26)</script><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>​        若只知道密文，则需要暴力枚举所有26种可能</p><p>​        <strong>词频统计</strong>：统计密文中字母出现的频率，与标准语言中字母出现的频率进行比对，确定密钥k的最可能的值</p><p><img src="/images/data_sec/image-20211208150718012.png" alt="image-20211208150718012" style="zoom: 67%;"></p><h2 id="仿射加密"><a href="#仿射加密" class="headerlink" title="仿射加密"></a>仿射加密</h2><h3 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h3><p>​        给定密钥（α，β）（α， β∈Z26）</p><script type="math/tex; mode=display">y=\alpha x+\beta\ (mod\ 26)</script><h3 id="解密过程-1"><a href="#解密过程-1" class="headerlink" title="解密过程"></a>解密过程</h3><script type="math/tex; mode=display">x = \frac{1}{\alpha}(y-\beta)\ (mod\ 26)</script><p>​        此处 1\α 是 α 的<strong>逆元</strong></p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>​        α 模 n 的逆元是满足 <strong>αγ=1 (mod n)</strong> 的 γ 的值，在仿射加密中，n 为26</p><h3 id="逆元存在定理"><a href="#逆元存在定理" class="headerlink" title="逆元存在定理"></a>逆元存在定理</h3><p>​        对于a，如果相对模数 n 存在逆元，则需满足 <strong>gcd(a,n) = 1</strong>，也就是 α 与 n 必须互质</p><h3 id="攻击方式-1"><a href="#攻击方式-1" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>​        暴力穷举：穷举出所有的312种可能，其中 β 有26种可能，α 为满足互质条件的12种可能</p><p>​        词频统计：仿射加密是线性映射，所以明文和对应密文出现的频率是一致的，具体方法是：统计密文中字母的频率，与标准字母频率比较，找到两个<strong>明文密文映射</strong></p><p>eg：</p><div class="table-container"><table><thead><tr><th style="text-align:center">密文频率</th><th style="text-align:center">标准字母频率</th></tr></thead><tbody><tr><td style="text-align:center">V：119</td><td style="text-align:center">e：12%</td></tr><tr><td style="text-align:center">W：67</td><td style="text-align:center">t：9%</td></tr><tr><td style="text-align:center">T：54</td><td style="text-align:center">a：8%</td></tr></tbody></table></div><p>​        最高频率的两组构成映射，解方程组即可得到对应解</p><script type="math/tex; mode=display">21 = 4α +β(mod26) \rightarrow 26m + 21 = 4α +β\\22 = 19α+β(mod26) \rightarrow 26m + 22 = 19α +β</script><h2 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h2><h3 id="加密过程——分组移位加密"><a href="#加密过程——分组移位加密" class="headerlink" title="加密过程——分组移位加密"></a>加密过程——分组移位加密</h3><p>​        列出明文并按照<strong>密钥长度分组</strong>，用密钥对<strong>每个组内</strong>字母进行移位加密（凯撒加密）：</p><script type="math/tex; mode=display">C=(P+K)\ mod\ 26</script><p>​        维吉尼亚密码实际上移位密码的一种扩展，能够<strong>消除字母的频率特征</strong></p><h5 id="攻击方式-2"><a href="#攻击方式-2" class="headerlink" title="攻击方式"></a>攻击方式</h5><p>​        <strong>找到密钥长度</strong>，把密文按照密钥长度L，选出密文中的第1个、第L+1、第2L+1个……字母进行词频统计，找出密钥，然后破解整个密码</p><h3 id="找到密钥长度的方法"><a href="#找到密钥长度的方法" class="headerlink" title="找到密钥长度的方法"></a>找到密钥长度的方法</h3><p>​        Kasiski实验：利用英文单词的规律，统计<strong>重复间隔</strong>，如 YC：间隔12。则公约数：1，2，3，4，6，12都可能是密钥长度</p><p><img src="/images/data_sec/image-20211208153410905.png" alt="image-20211208153410905" style="zoom:67%;"></p><p>​        Friedman测试：重合指数表示两个随机选出的字母是相同的的概率，即随机选出两个A的概率+随机选出两个B的概率+随机选出两个C的概率+……+随机选出两个Z的概率。假设密钥长度为1，P = 0.065（标准词频统计得到），若按照分组每组的重合指数都很接近0.065，那么当前的分组长度即是密钥长度。</p><p>​        频率分析</p><h1 id="五、对称密码与DES"><a href="#五、对称密码与DES" class="headerlink" title="五、对称密码与DES"></a>五、对称密码与DES</h1><h3 id="流密码（streaming-cipher）"><a href="#流密码（streaming-cipher）" class="headerlink" title="流密码（streaming cipher）"></a>流密码（streaming cipher）</h3><p>​        每次加密数据流的一位或者一个字节。如古典密码学，如一次性密码本</p><h3 id="分组密码（block-cipher）"><a href="#分组密码（block-cipher）" class="headerlink" title="分组密码（block cipher）"></a>分组密码（block cipher）</h3><p>​        将明文分组作为整体加密并且通常得到与明文等长的密文分组，也称之为块密码</p><p>​        需要满足的要求：分组长度N要足够大，防止明文穷举法攻击</p><h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>​        使密钥与密文之间的关系尽可能模糊的加密操作，明文不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来；密钥不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来。</p><h3 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h3><p>​        为了隐藏明文统计属性而将一个明文符号的影响扩散到多个密文符号的加密操作，即让明文中的每一位影响密文中的<strong>尽可能多的位</strong>，如位置换。通常修改明文中1位会导致平均一半的输出位发生变化</p><h2 id="分组密码算法要求"><a href="#分组密码算法要求" class="headerlink" title="分组密码算法要求"></a>分组密码算法要求</h2><h3 id="分组长度N要足够大"><a href="#分组长度N要足够大" class="headerlink" title="分组长度N要足够大"></a>分组长度N要足够大</h3><p>​        防止明文穷举法攻击</p><h3 id="密钥量要足够大"><a href="#密钥量要足够大" class="headerlink" title="密钥量要足够大"></a>密钥量要足够大</h3><p>​        尽可能消除弱密钥并使所有密钥同等地好，以防止密钥穷举攻击奏效</p><h3 id="由密钥确定置换的算法要足够复杂"><a href="#由密钥确定置换的算法要足够复杂" class="headerlink" title="由密钥确定置换的算法要足够复杂"></a>由密钥确定置换的算法要足够复杂</h3><p>​        充分实现明文与密钥的扩散和混淆，没有简单的关系可循，要能抗击各种已知的攻击</p><h3 id="加密和解密运算简单"><a href="#加密和解密运算简单" class="headerlink" title="加密和解密运算简单"></a>加密和解密运算简单</h3><p>​        易于软件和硬件高速实现</p><h3 id="数据扩展"><a href="#数据扩展" class="headerlink" title="数据扩展"></a>数据扩展</h3><p>​        一般无数据扩展，在采用同态置换和随机化加密技术时可引入数据扩展</p><h3 id="差错传播尽可能地小"><a href="#差错传播尽可能地小" class="headerlink" title="差错传播尽可能地小"></a>差错传播尽可能地小</h3><p>​        一个密文分组的错误尽可能少的影响其他密文分组的解密</p><h2 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h2><h3 id="参数特性"><a href="#参数特性" class="headerlink" title="参数特性"></a>参数特性</h3><p>​         分组大小: 分组越大则安全性越高，但加密速度就越慢。</p><p>​        密钥大小：密钥越长则安全性越高，但加密速度就越慢。</p><p>​        轮数：单轮结构远不足以保证安全性，但多轮结构可提供足够的安全性。典型地，轮数取为16。</p><p>​        子密钥产生算法：该算法的复杂性越大，则密码分析的困难性就越大。</p><p>​        轮函数：轮函数的复杂性越大，密码分析的困难性也越大。</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>​        快速的软件实现：在很多情况中，算法是被镶嵌在应用程序中，因而无法用硬件实现。此时算法的执行速度是考虑的关键。</p><p>​        算法容易分析：如果算法能被无疑义地解释清楚，就可容易地分析算法抵抗攻击的能力，有助于设计高强度的算法。</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>​        输入分组长度为 2w 的明文和密钥 k 将每组明文分成左右两段，n轮迭代完毕后，合并生成最终的密文，每个分组是使用的密钥也不同，Ki 表示第 i 轮使用的轮密钥</p><script type="math/tex; mode=display">L_i = R_{i-1}\\R_i = L_{i-1} \ \oplus \  F(R_{i-1},K_i)</script><p>​        解密过程是加密的逆过程，以密文作为输入，轮密钥使用的次序和加密过程相反</p><h3 id="流程总体图"><a href="#流程总体图" class="headerlink" title="流程总体图"></a>流程总体图</h3><p><img src="/images/data_sec/image-20211208161541998.png" alt="image-20211208161541998" style="zoom:80%;"></p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>​        加密和解密都使用<strong>同一把密钥</strong>，对称加密的保密性的关键是<strong>密钥的保密性</strong></p><p><img src="/images/data_sec/image-20211208163333687.png" alt="image-20211208163333687" style="zoom: 67%;"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>​        加密：C = E(K,M)</p><p>​        解密：M = D(K,C)</p><h3 id="条件保证"><a href="#条件保证" class="headerlink" title="条件保证"></a>条件保证</h3><p>​        加密算法安全性：该条件要求即使攻击者窃取到一定数量的密文和对应的明文，也无法破译</p><p>​        密钥保密性：通信双方通过安全信道获得对方的密钥并进行安全存储</p><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>​        DES （Data Encryption Standard）是一种使用<strong>56位密钥</strong>（有效56位，实际64位包含8位校验位）对<strong>64位长分组</strong>进行加密的密码，是一种迭代算法，DES是第一个公开的分组加密算法</p><p><img src="/images/data_sec/image-20211208163956600.png" alt="image-20211208163956600" style="zoom:67%;"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>​        DES对明文中每个分组的加密过程都包含<strong>16轮</strong>，且每轮的操作都完全相同。<strong>每轮使用不同的子密钥</strong>，但是子密钥是从主密钥中推导而来</p><h3 id="加密过程-2"><a href="#加密过程-2" class="headerlink" title="加密过程"></a>加密过程</h3><p><img src="/images/data_sec/image-20211208165352531.png" alt="image-20211208165352531" style="zoom:67%;"></p><h4 id="初始置换IP"><a href="#初始置换IP" class="headerlink" title="初始置换IP"></a>初始置换IP</h4><p>​        将64 bit明文的位置进行置换，得到一个乱序的64 bit明文组，按照下表的方式进行逐位替换</p><script type="math/tex; mode=display">M=m_1\ m_2… m_{64} \ \rightarrow \ IP(M)=m_{58}\ m_{50}… m_7</script><p><img src="/images/data_sec/image-20211208165600769.png" alt="image-20211208165600769" style="zoom: 67%;"></p><h4 id="轮内加密"><a href="#轮内加密" class="headerlink" title="轮内加密"></a>轮内加密</h4><p><img src="/images/data_sec/image-20211208170928339.png" alt="image-20211208170928339" style="zoom:67%;"></p><p>​        整体的DES算法是建立在Feistel密码思想基础上的，每轮实现一次轮内加密，主要分为<strong>扩展置换</strong>、<strong>S盒变换</strong>、<strong>置换P</strong>三个步骤实现每轮的加密过程，也就是上图的F函数。</p><p><img src="/images/data_sec/image-20211208170756386.png" alt="image-20211208170756386" style="zoom:67%;"></p><p>​        扩展置换是按照下图中的矩阵进行密钥的扩展，将32位的密码扩展形成48位的密码，每四位的密码将第一位向前扩展一位，降低四位向后扩展一位，形成6位的新密码，矩阵中即为要扩展的位数的下标</p><p><img src="/images/data_sec/image-20211208212733317.png" alt="image-20211208212733317"></p><p><img src="/images/data_sec/QQ截图20211208171714.png"></p><p>​        S盒操作时将扩展后的密码全部在压缩成32位，新扩展出的两位形成的二进制数作为行标，原有的密码作为列标，在S盒中查找新生成的十六进制数，再将其转为二进制即可得到压缩后的新的4位密码。例如010100查找00行和1010列，得到的转化后的密码为0110</p><p><img src="/images/data_sec/image-20211208213312179.png" alt="image-20211208213312179" style="zoom:67%;"></p><p><img src="/images/data_sec/image-20211208212907316.png" alt="image-20211208212907316" style="zoom:80%;"></p><p>​        置换P，是在生成的新的32为密码之上，对每一位进行按照如下表中的数字转化，对应位置转化成新位置的值</p><p><img src="/images/data_sec/QQ截图20211208213504.png" style="zoom: 80%;"></p><h4 id="逆置换"><a href="#逆置换" class="headerlink" title="逆置换"></a>逆置换</h4><p>​        初始置换IP的逆变换</p><script type="math/tex; mode=display">M=m_1\ m_2… m_{64} \ \rightarrow \ IP(M)=m_{40}\ m_8… m_{25}</script><p><img src="/images/data_sec/image-20211208170042504.png" alt="image-20211208170042504" style="zoom:67%;"></p><h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h4><p>​        密钥包含64位，包含8位校验位，实际56位参与运算，每次进行一次置换盒F函数之后，都需要进行密钥的<strong>循环左移</strong>，每次迭代密钥需要左移的数目都是不同的</p><p><img src="/images/data_sec/image-20211208220126297.png" alt="image-20211208220126297" style="zoom:80%;"></p><h3 id="安全性与优势"><a href="#安全性与优势" class="headerlink" title="安全性与优势"></a>安全性与优势</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>​        解密的过程和加密过程完全相同</p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>​        密钥长度较短，<strong>穷举搜索</strong>的方法已经对DES造成了较大的威胁，因此提出了多重DES以缓解因为密钥长度不足带来的安全性问题，通过对同一消息加密多次以增强安全性。</p><h2 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>​        使用多个密钥利用DES进行多次加密，增加密钥量以提高抵抗穷举密钥搜索攻击的能力。</p><h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h3><p>​        由三个连续的DES加密组成，也称之为三重DES。三个密码组件既可以是一个加密函数又可以是一个解密函数。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>​        克服了DES面临的穷举攻击，增强了抗差分分析和线性分析的能力，更新算法成本较小，抗分析能力更强</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>​        处理速度较慢，实现效率较低，明文分组长度没有改变，分组较小仍然只有64位，与密钥的长度增长不匹配</p><h1 id="六、数论基础"><a href="#六、数论基础" class="headerlink" title="六、数论基础"></a>六、数论基础</h1><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>​        实质是辗转相除法，上一次结果的商作为新一次结果的被除数，上一次结果的模作为新一次结果的除数</p><script type="math/tex; mode=display">gcd(a,b) = gcd(b,a\  mod\ b)</script><h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><h3 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h3><p>​        若 n|(a-b)，则a ≡ b(mod n)</p><p>​        若a ≡ b(mod n),，则有b ≡ a(mod n)</p><p>​        若a ≡ b(mod n),，b ≡ c(mod n)， 则有a ≡ c(mod n)</p><h3 id="模运算性质"><a href="#模运算性质" class="headerlink" title="模运算性质"></a>模运算性质</h3><p>​        加法同模：[(a mod n) + (b mod n)] mod n = (a + b) mod n</p><p>​        减法同模：[(a mod n) –  (b mod n)] mod n = (a - b) mod n</p><p>​        乘法同模：[(a mod n) x (b mod n)] mod n = (a x b) mod n</p><h2 id="剩余类"><a href="#剩余类" class="headerlink" title="剩余类"></a>剩余类</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>​        给定正整数m，全体整数可按照模m是否同余分为若干两两不相交的集合，使得每一个集合中的任意两个正整数对模m一定同余，而属于不同集合的任意两个整数对模m不同余，每一个这样的集合称为模m的剩余类</p><p><img src="/images/data_sec/image-20211208224806518.png" alt="image-20211208224806518" style="zoom:67%;"></p><h3 id="剩余类互素"><a href="#剩余类互素" class="headerlink" title="剩余类互素"></a>剩余类互素</h3><p>​        在模m的一个剩余类当中，如果有一个数与m互素，则该剩余类中所有的数均与m互素</p><h2 id="扩展的欧几里得（求逆元）"><a href="#扩展的欧几里得（求逆元）" class="headerlink" title="扩展的欧几里得（求逆元）"></a>扩展的欧几里得（求逆元）</h2><p>​        对于给定整数a,b，拓展的欧几里得算法不仅可以计算出最大公因子d, 而且可以得到两个整数x,y，并满足：</p><script type="math/tex; mode=display">ax + by = d = gcd (a, b)</script><p>​        如果a,b 互素，<strong>b 有模a的乘法逆元：b-1 = y</strong></p><h2 id="欧拉定理与费马小定理"><a href="#欧拉定理与费马小定理" class="headerlink" title="欧拉定理与费马小定理"></a>欧拉定理与费马小定理</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>​        与m互素的剩余类的个数称为欧拉函数，记为φ(m)，𝜑(𝑚) 等于 Zm 当中与m互素的数的个数。</p><p>​        对于任意一个素数m，φ(m) = m−1</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>​        r、m互素格式（<strong>gcd(r,m) = 1</strong>）：设 m 是正整数，r ∈Zm（0，1，2…，m-1的最小非负完全剩余系）</p><script type="math/tex; mode=display">r^{φ(m)}=1(mod\ m).</script><p>​        不要求r、m互素的格式</p><script type="math/tex; mode=display">r^{φ(m)+1}\ =\ r(mod\ m)</script><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>​        r、m互素格式：如果m是素数，r ∈Zm（0，1，2…，m-1的最小非负完全剩余系）</p><script type="math/tex; mode=display">r^{m−1} \ =\ 1(mod\ m).</script><p>​        不要求r、m互素的格式</p><script type="math/tex; mode=display"> r^{m}\ =\ r(mod\ m)</script><h2 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>​        有限域的阶必是一个素数的幂，n是整数，阶为p^n的有限域可记为GF(p^n)；有p个元素的有限域记为GF(P)</p><h3 id="有限域GF-p"><a href="#有限域GF-p" class="headerlink" title="有限域GF(p)"></a>有限域GF(p)</h3><p>​        给定一个素数p，有限域GF(p)被定义为整数 {0, 1, …, p-1}的集合Z_p，其运算是<strong>模p</strong>的算术运算</p><p>​        GF(p)中任意元素w，存在其逆元w^−1 = z，使得<strong>w × z ≡ 1 mod p</strong></p><h3 id="多项式运算（乘法、加法）"><a href="#多项式运算（乘法、加法）" class="headerlink" title="多项式运算（乘法、加法）"></a>多项式运算（乘法、加法）</h3><p>​        系数在zp中的多项式运算要求在计算每个系数的值时需要做<strong>模计算</strong></p><h3 id="不可约多项式"><a href="#不可约多项式" class="headerlink" title="不可约多项式"></a>不可约多项式</h3><p>​        在域F上，若一个多项式不能写成两个多项式的乘积，则被称为不可约多项式或素多项式</p><script type="math/tex; mode=display">x^3+x^2+x+1 \ \ \ \ \ x^4+x+1\ \ \ ……</script><h3 id="有限域GF-2-n"><a href="#有限域GF-2-n" class="headerlink" title="有限域GF(2^n)"></a>有限域GF(2^n)</h3><p>​        如果乘法运算的结果是次数大于n−1的多项式，那么必须将其除以某个次数为n的既约多项式m(x)并取余。对于多项式f(x)，其余数可表示为 r(x) = f(x) mod m(x)。</p><h3 id="多项式加法"><a href="#多项式加法" class="headerlink" title="多项式加法"></a>多项式加法</h3><p>​        将相应的多项式系数相加，对于Z2上的多项式可看作<strong>异或运算</strong></p><p><img src="/images/data_sec/image-20211208235012873.png" alt="image-20211208235012873" style="zoom:67%;"></p><h3 id="多项式乘法——传统法"><a href="#多项式乘法——传统法" class="headerlink" title="多项式乘法——传统法"></a>多项式乘法——传统法</h3><p>​        乘以x的运算可以通过<strong>左移一位</strong>后再根据条件<strong>按位异或</strong>既约多项式</p><p><img src="/images/data_sec/image-20211208235120428.png" alt="image-20211208235120428" style="zoom: 80%;"></p><h3 id="多项式乘法——二进制法"><a href="#多项式乘法——二进制法" class="headerlink" title="多项式乘法——二进制法"></a>多项式乘法——二进制法</h3><script type="math/tex; mode=display">f(x)=x^6+x^4+x^2+x+1\\g(x)=x^7+x+1\\m(x)=x^8+x^4+x^3+x+1</script><p>​        我们将使用二进制的方式重新计算f(x) × g(x) mod m(x)的过程，首先要先求出x幂乘01010111的中间结果</p><p><img src="/images/data_sec/image-20211208234732055.png" alt="image-20211208234732055" style="zoom:80%;"></p><p>（ps：不考最大公约数，不考多项式的乘法逆元）</p><h1 id="七、AES"><a href="#七、AES" class="headerlink" title="七、AES"></a>七、AES</h1><h2 id="加密标准"><a href="#加密标准" class="headerlink" title="加密标准"></a>加密标准</h2><p>​        明文分组<strong>128位</strong>，三种密钥标准：128位、192位、256位，应用最广泛的对称算法</p><h2 id="评估准则"><a href="#评估准则" class="headerlink" title="评估准则"></a>评估准则</h2><p>​        一般安全性、软件实现、受限空间环境、硬件实现、抵御密码分析攻击、密钥灵活性、其他的多功能性和灵活性、指令级并行执行的潜力</p><h2 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h2><p>​        采用<strong>非feistel的结构</strong>，共分为11轮，<strong>密钥扩展</strong>成由44个32位字组成的数组，每轮使用4个。每轮执行四步过程：<strong>字节替换</strong>、<strong>行位移</strong>、<strong>列混淆</strong>、<strong>轮密钥加</strong>，第一轮开始前先进行一次密钥扩展，最后一轮不进行列混淆。</p><p><img src="/images/data_sec/image-20211209143634384.png" alt="image-20211209143634384" style="zoom:80%;"></p><h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p>​        对每四个列密钥进行计算，若当前列密钥为当前轮的首列，先对该列循环左移操作，然后经过S盒转化，再与当前轮次的轮密钥异或运算即可得到新的列密钥</p><p><img src="/images/data_sec/image-20211209145112778.png" alt="image-20211209145112778" style="zoom: 50%;"></p><p><img src="/images/data_sec/image-20211209145350822.png" alt="image-20211209145350822" style="zoom:50%;"></p><p>​        非当前轮的首列，则将原列与扩展后的新首列进行异或，一次得到全部的当前轮次的扩展密钥</p><p><img src="/images/data_sec/image-20211209150450503.png" alt="image-20211209150450503" style="zoom:50%;"></p><h3 id="字节替换"><a href="#字节替换" class="headerlink" title="字节替换"></a>字节替换</h3><p>​        将当前明文中的每一项全部经过S盒转化，每一项均是一个十六进制数，第一位作为S盒查找的行，第二位作为S盒查找的列，找出对应替换的十六进制数</p><p><img src="/images/data_sec/image-20211209150807478.png" alt="image-20211209150807478" style="zoom:50%;"></p><h3 id="行位移"><a href="#行位移" class="headerlink" title="行位移"></a>行位移</h3><p>​        第一行不变，第二行左移动1个字节，第三行左移动2个字节，第四行左移动3个字节，实现了列间的置换</p><p><img src="/images/data_sec/image-20211209151219950.png" alt="image-20211209151219950" style="zoom:67%;"></p><h3 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h3><p>​        每一列单独处理，每列中每个字节被替换成本列中所有4个字节都相关的结果，具体操作是每一列都与固定的混淆矩阵相乘，<strong>其上的乘法和加法均是基于GF(2^8)上的二元运算</strong></p><p><img src="/images/data_sec/image-20211209151338341.png" alt="image-20211209151338341" style="zoom:80%;"></p><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>​        将16字节的当前状态矩阵和长度为16字节的子钥进行异或。</p><p><img src="/images/data_sec/image-20211209151734243.png" alt="image-20211209151734243" style="zoom:67%;"></p><h1 id="八、公钥密码体制与RSA"><a href="#八、公钥密码体制与RSA" class="headerlink" title="八、公钥密码体制与RSA"></a>八、公钥密码体制与RSA</h1><h3 id="对称密钥体制缺陷"><a href="#对称密钥体制缺陷" class="headerlink" title="对称密钥体制缺陷"></a>对称密钥体制缺陷</h3><p>​        <strong>密钥分发信道不得公开，密钥管理成本高，不支持开放系统（无信道无法共享密钥）</strong></p><p>​        对称密码体制允许两个用户利用提前共享的秘密来建立安全信道”，然而通信双方共享秘密并不容易；当具有N个用户两两之间都需要进行安全通信时，采用对称密码体制来保护用户之间的通信， 每个用户需要与其余的N -1个用户共享私钥，整个系统需要管理N(N -1)/2个密钥</p><h2 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>​        <strong>加密容易解密难</strong></p><h3 id="密钥生成与加解密"><a href="#密钥生成与加解密" class="headerlink" title="密钥生成与加解密"></a>密钥生成与加解密</h3><p>​        通过相对容易的计算过程生成一对公钥PK与私钥SK。如果仅获得公钥PK，得到私钥SK的操作在计算上是不可行的，加密给定明文M与公钥PK，很容易计算得到密文C=EPK(M)，给定密文C=EPK(M) 和私钥SK，很容易计算得到明文M，但如果缺少私钥SK，从密文C中是不可以计算得到明文M的。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>​        加密/解密：发送方使用接收方的公钥对消息加密。</p><p>​        签名： 发送方使用其私钥对消息“签名”。</p><p>​        密钥交换：通信双方交换会话密钥。</p><h3 id="公钥密码的优势（与对称密码缺陷一一对应）"><a href="#公钥密码的优势（与对称密码缺陷一一对应）" class="headerlink" title="公钥密码的优势（与对称密码缺陷一一对应）"></a>公钥密码的优势（与对称密码缺陷一一对应）</h3><h4 id="密钥分发"><a href="#密钥分发" class="headerlink" title="密钥分发"></a>密钥分发</h4><p>​        公钥能够采用公开（认证的）信道进行传输；</p><h4 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h4><p>​        在N个用户的系统中，每个用户只需安全保管自己的私钥和N-1个其他用户的公钥。整个系统仅仅需要维护N个公钥</p><h4 id="开放系统"><a href="#开放系统" class="headerlink" title="开放系统"></a>开放系统</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><div class="code-wrapper"><pre n><code>     即使是没有预先建立关系的用户也能通过对方的公钥建立安全通信</code></pre></div></div><p><img src="/images/data_sec/image-20211209154224405.png" alt="image-20211209154224405"></p><h2 id="RSA（计算）"><a href="#RSA（计算）" class="headerlink" title="RSA（计算）"></a>RSA（计算）</h2><h3 id="密钥生成-1"><a href="#密钥生成-1" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>​        选择两个大素数p，q（例如：每个数字1024位）</p><p>​        选择</p><script type="math/tex; mode=display">n = pq，z = \phi(n) = (p-1)(q-1)</script><p>​        随机选取 e（其中 e &lt; n），e 与 z 没有公约数（e，z 互为质数）</p><p>​        选取 d 使得 ed - 1 能够被z完全整除（即 ed mod z = 1）</p><p>​        <strong>公钥是 (n, e) ，私钥是（n, d）</strong></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>​        将明文 m 通过如下计算转变为密文 c</p><script type="math/tex; mode=display">c=m^e \ \ mod\ \  n</script><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>​        将密文 c 通过如下计算恢复成明文 m</p><script type="math/tex; mode=display">m=c^d\ \ mod\ \  n</script><p><img src="/images/data_sec/image-20211209155651795.png" alt="image-20211209155651795" style="zoom:50%;"></p><p>（ps：不涉及证明）</p><h3 id="RSA安全"><a href="#RSA安全" class="headerlink" title="RSA安全"></a>RSA安全</h3><h4 id="针对RSA的攻击"><a href="#针对RSA的攻击" class="headerlink" title="针对RSA的攻击"></a>针对RSA的攻击</h4><p>​        穷举攻击、数学攻击、计时攻击、基于硬件故障的攻击、选择密文攻击</p><h4 id="RSA安全本质"><a href="#RSA安全本质" class="headerlink" title="RSA安全本质"></a>RSA安全本质</h4><p>​        素数的分解问题，大合数分解的难解性，破解RSA密钥成为计算上的不可解问题</p><h1 id="九、密钥交换协议"><a href="#九、密钥交换协议" class="headerlink" title="九、密钥交换协议"></a>九、密钥交换协议</h1><h3 id="有限域上的离散对数问题"><a href="#有限域上的离散对数问题" class="headerlink" title="有限域上的离散对数问题"></a>有限域上的离散对数问题</h3><p>​        设 F 是一个有限域，则在一直 F 中的元 a 和 b，求解整数x，使得</p><script type="math/tex; mode=display">a^x = b</script><p>在有限域 F 中成立的问题，称为有限域 F 上的离散对数问题</p><p>​        其与大合数分解问题一样在计算上不可行，它是密钥交换协议的安全保障</p><h2 id="D—H密钥交换协议"><a href="#D—H密钥交换协议" class="headerlink" title="D—H密钥交换协议"></a>D—H密钥交换协议</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>​        参数选取：选取大素数 p，选取 zp 的一个本原根 g，并将 p 和 g <strong>公开</strong>，全网可用</p><p>​        密钥协商：Alice选择要给<strong>秘密整数 a</strong>，计算 A=g^a mod p 并发送给Bob，Bob选择要给<strong>秘密整数 b</strong>， 计算 B=g^b mod p 并发送给Alice，双方利用如下的方式计算（协商）得到密钥 k</p><script type="math/tex; mode=display">k = B^a = (g^b)^a\  mod\ p \\k = A^b = (g^a)^b\ mod\ p</script><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>​        任何两个人都可以协商出会话密钥，不需要事先拥有对方的公开或者秘密的信息。每次密钥交换后不必要在保留秘密信息，减少了保密的负担。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>​        容易受到中间人攻击，攻击者在信道之间，假冒Bob，与Alice进行密钥交换；同时假冒Alice，与Bob进行密钥交换。最终达到一种虚假的Alice和Bob进行密钥交换的假象，实则两人都是与攻击者进行的密钥交换。</p><p><img src="/images/data_sec/image-20211213210020629.png" alt="image-20211213210020629" style="zoom: 67%;"></p><p>​        遭受中间人攻击的原因：协议与对方的身份信息无关，<strong>未能进行身份认证</strong></p><h2 id="ELGAMAL密码体制"><a href="#ELGAMAL密码体制" class="headerlink" title="ELGAMAL密码体制"></a>ELGAMAL密码体制</h2><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><p>​        选取有限域GF(q)，再选取有限域GF(q)的一个本原根 a，并将 GF(q) 和 a 公开（首先要随机选择一个大素数p，且要求p-1有大素数因子。再选择一个模p的本原元α），随机选取整数d，并计算出</p><script type="math/tex; mode=display">β = a^d， 1\leq d\leq q-2</script><p>将β作为公开的加密密钥，将d作为保密的脱密密钥。</p><p>​        对于明文，随机选取随机数k，1≤k≤p-2，加密过程为</p><script type="math/tex; mode=display">c_1 = a^k \ mod\  p</script><script type="math/tex; mode=display">c_2 = m*b^k\  mod\  p</script><p>​        解密过程为，利用欧几里得算法求解逆元</p><script type="math/tex; mode=display">M = c_2*({c_1}^d)^{-1} \ mod\  p</script><h2 id="椭圆曲线加密"><a href="#椭圆曲线加密" class="headerlink" title="椭圆曲线加密"></a>椭圆曲线加密</h2><h3 id="椭圆曲线上的加法与乘法"><a href="#椭圆曲线上的加法与乘法" class="headerlink" title="椭圆曲线上的加法与乘法"></a>椭圆曲线上的加法与乘法</h3><p>​        椭圆曲线的基本方程是</p><script type="math/tex; mode=display">y^2 = x^3 + ax+b</script><p>​        椭圆曲线上加法运算的准则是：若曲线上的三个点在同一条直线上，则他们的和为O，O为加法单位元</p><p>​        具体应用到求解椭圆曲线上的两个点的加法方式如下：若两个点互为负元，即具有相同x坐标和相反y坐标，则他们的和为O；若两个点不相同则在这两点连一条直线，并寻找这条直线与椭圆曲线的交点，这个交点的横纵坐标相反数即是两个点的和；若两个点相同则做一条过该点的切线，这条切线与椭圆曲线的交点的坐标相反数即是两个点的和。</p><p><img src="/images/data_sec/QQ截图20211021164035.png" style="zoom:80%;"></p><p>​        具体应用到整数域下的椭圆曲线加法如下：求解P、Q两点的加法公式如下</p><script type="math/tex; mode=display">x_r = (\lambda^2 - x_p - x_q) mod\ p \\y_r = (\lambda(x_p-x_r)-y_p)mod\ p</script><p>​        其中对于两点是否相同规定了不同的参数值</p><script type="math/tex; mode=display">\lambda = \left\{\begin{aligned}\frac{y_q - y_p}{x_q-x_p} mod\ p  \ \ \  if\  P\neq Q\\\\\frac{3x_p^2+a}{2y_p}mod\ p  \ \ \  if\  P= Q\end{aligned}\right.</script><p>​        而对于椭圆曲线上的乘法即<strong>循环执行多次加法得到</strong></p><h3 id="椭圆曲线的加密算法"><a href="#椭圆曲线的加密算法" class="headerlink" title="椭圆曲线的加密算法"></a>椭圆曲线的加密算法</h3><p>​        椭圆曲线的加解密算法需要确定一个大素数q，椭圆曲线的参数a和b，并选取一个阶数够高的点G，这些参数均对外公开，然后用户选定一个<strong>私钥nA</strong>，经过</p><script type="math/tex; mode=display">P_A = n_AG</script><p>​        得到公开的加密密钥</p><p>​        随后用户选定一个随机数k，选定需要加密的明文pm，并按照椭圆曲线计算规则计算分别计算密文的两段参数值，加密过程使用的即之前产生的公钥pA</p><script type="math/tex; mode=display">C_m = \left\{ kG,P_m+kP_A\right\}</script><p>​        得到密文后，利用</p><script type="math/tex; mode=display">P_m = C_2 - n_AC_1</script><p>​        重新可以得到原来的明文</p><h1 id="十、数字签名"><a href="#十、数字签名" class="headerlink" title="十、数字签名"></a>十、数字签名</h1><h2 id="签名的目的与作用"><a href="#签名的目的与作用" class="headerlink" title="签名的目的与作用"></a>签名的目的与作用</h2><p>​        1、表示签名者对消息的认可;</p><p>​        2、他人可识别和验证出是谁的签名</p><p>​        3、他人无法伪造和更改签名：即无法凭空造出一个签名；对一个文件的签名不能复制或篡改成对另一个文件的签名</p><p>​        4、可仲裁性：出现争议时第三方可仲裁，仲裁的内容: 签名者是否在抵赖，否认签名；验证者是否在欺诈，伪造签名。</p><p>​        签名的实现方式：就是在原文件上追加一定的笔迹信息，并使二者形成一个整体。</p><h2 id="数字签名应满足的条件"><a href="#数字签名应满足的条件" class="headerlink" title="数字签名应满足的条件"></a>数字签名应满足的条件</h2><h3 id="签名应与文件是一个不可分割的整体"><a href="#签名应与文件是一个不可分割的整体" class="headerlink" title="签名应与文件是一个不可分割的整体 ;"></a>签名应与文件是一个不可分割的整体 ;</h3><p>​        实现：对消息进行某种变换完成签名；使签名是待签名的文件的函数。</p><h3 id="签名者事后不能否认自己的签名："><a href="#签名者事后不能否认自己的签名：" class="headerlink" title="签名者事后不能否认自己的签名："></a>签名者事后不能否认自己的签名：</h3><p>​        实现：签名是通过发方所独有的秘密信息来完成，并且该秘密信息对应惟一公开的验证信息，使签名者不能抵赖自己的签名。</p><h3 id="接收者能验证签名，而任何其他人都不能伪造签名；"><a href="#接收者能验证签名，而任何其他人都不能伪造签名；" class="headerlink" title="接收者能验证签名，而任何其他人都不能伪造签名；"></a>接收者能验证签名，而任何其他人都不能伪造签名；</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><div class="code-wrapper"><pre n><code>     实现：签名必须与特定的公开信息相对应，使收方能够验证；签名应与签名者独有的秘密信息密切相关，使其他人不能伪造。</code></pre></div></div><h3 id="当双方关于签名的真伪发生争执时，一个法官或第三方能解决双方之间发生的争执："><a href="#当双方关于签名的真伪发生争执时，一个法官或第三方能解决双方之间发生的争执：" class="headerlink" title="当双方关于签名的真伪发生争执时，一个法官或第三方能解决双方之间发生的争执："></a>当双方关于签名的真伪发生争执时，一个法官或第三方能解决双方之间发生的争执：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><div class="code-wrapper"><pre n><code>     实现：签名对应的验证密钥应由可信的第三方确认并公布。当发生争执时，靠法律解决争端。 </code></pre></div></div><h2 id="数字签名实现"><a href="#数字签名实现" class="headerlink" title="数字签名实现"></a>数字签名实现</h2><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><p>​        用户A将其<strong>私钥 kd</strong> 作为其<strong>签名密钥</strong>, 将对应的<strong>公钥 ke</strong> 作为其<strong>签名识别密钥</strong></p><h3 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h3><p>​        利用签名密钥 kd 对 m 执行脱密变换D，得到签名</p><script type="math/tex; mode=display">sign(m) = D_{k_d}(m)</script><p>​        签名者将<strong>文件 m 及其签名 sign(m) 一起公布</strong> </p><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>​        利用用户A的签名识别密钥 ke 对签名 sign(m) 执行加密变换E，得到</p><script type="math/tex; mode=display">E_{k_e}(sign(m)) = E_{k_e}(D_{k_d}(m))</script><p>​        若其<strong>与m相等</strong>，则判断sign(m)是用户A对文件m的签名；否则，sign(m)不是用户A对文件m的签名。</p><h2 id="RSA数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h2><p>​        记用户A的参数为（NA , eA, dA） ，用户B的参数为（NB , eB, dB），E为加密算法，D为脱密算法</p><h3 id="RSA加密解密"><a href="#RSA加密解密" class="headerlink" title="RSA加密解密"></a>RSA加密解密</h3><p>​        加密解密均使用 B 的密钥（需要接收方自己解出来），使用<strong>公钥加密，私钥解密</strong></p><p><img src="/images/data_sec/QQ截图20211222165032.png" style="zoom:80%;"></p><h3 id="RSA签名验证"><a href="#RSA签名验证" class="headerlink" title="RSA签名验证"></a>RSA签名验证</h3><p>​        签名验证均使用 A 的密钥（<strong>因为是信息发送者需要签名</strong>），使用<strong>私钥签名</strong>（可以理解为自己独有的字体），<strong>公钥验证</strong></p><p>​        我们将 m 和 c 一起发送，作为签名（m, c）</p><p><img src="/images/data_sec/QQ截图20211222165058.png" alt="QQ截图20211222165058" style="zoom:80%;"></p><h3 id="数字签名流程"><a href="#数字签名流程" class="headerlink" title="数字签名流程"></a>数字签名流程</h3><p><img src="/images/data_sec/QQ截图20211222165424.png" style="zoom: 80%;"></p><p>​        1、参数选择和密钥生成</p><p>​        2、签名过程：用户A对信息M进行签名，计算</p><script type="math/tex; mode=display">S=Sig(M)=𝑀^𝑑 \ 𝑚𝑜𝑑\  𝑛</script><p>​        3、M+S</p><p>​        4、验证过程：用户B验证用户A对信息M的数字签名，计算</p><script type="math/tex; mode=display">𝑀^′ =Ver(S)=S^𝑒\ mod\ \ n \\𝑀^′=M?</script><h2 id="加密与签名结合的RSA"><a href="#加密与签名结合的RSA" class="headerlink" title="加密与签名结合的RSA"></a>加密与签名结合的RSA</h2><p>​        仍记用户A的参数为（NA , eA, dA） ，用户B的参数为（NB , eB, dB）</p><h3 id="当NA-lt-NB时，先签名，后加密"><a href="#当NA-lt-NB时，先签名，后加密" class="headerlink" title="当NA&lt;NB时，先签名，后加密"></a>当NA&lt;NB时，先签名，后加密</h3><p>​        用户A先用自己的保密密钥 dA 对消息m进行签名，得到</p><script type="math/tex; mode=display">y = m^{d_A} \ mod\ N_A</script><p>​        A再用用户B的公开密钥 eB 对签名y进行加密，得到</p><script type="math/tex; mode=display">c = y^{e_B} \ mod\ N_B</script><p>​        然后将既签名，又加密了的 c 发送给用户B，B收到 c 后，先进行变换：</p><script type="math/tex; mode=display">y = c^{d_B} \ mod\ N_B</script><p>​        再用A的公开密钥作变换：</p><script type="math/tex; mode=display">m = y^{e_A} \ mod\ N_A</script><p>​        从而验证签名来自A</p><h3 id="当NA-gt-NB时，先加密，后签名"><a href="#当NA-gt-NB时，先加密，后签名" class="headerlink" title="当NA&gt;NB时，先加密，后签名"></a>当NA&gt;NB时，先加密，后签名</h3><p>​        用户A先用B的公开密钥 eB 对消息m进行加密，得到：</p><script type="math/tex; mode=display">y = m^{e_B} \ mod\ N_B</script><p>​        A再用自己的保密密钥 dA 对y进行签名，得到</p><script type="math/tex; mode=display">c = y^{d_A} \ mod\ N_A</script><p>​        然后将既签名，又加密了的 c 发送给用户B，B收到c后，先进行变换： </p><script type="math/tex; mode=display">y = c^{e_A} \ mod\ N_A</script><p>​        再用自己的保密密钥作变换：</p><script type="math/tex; mode=display">m = y^{d_B} \ mod\ N_B</script><p>​        从而验证签名来自A</p><p>​        但是这样存在一个问题：攻击者C先用A的公开密钥求出y，再用自己的私钥对y签名。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>​        系统中的每个用户采用两个模数，一个用于加密，一个用于签名。并且保证<strong>所有用户的签名模数均小于其他用户的加密模数</strong>。</p><h2 id="RSA缺点"><a href="#RSA缺点" class="headerlink" title="RSA缺点"></a>RSA缺点</h2><h3 id="第三方攻击者"><a href="#第三方攻击者" class="headerlink" title="第三方攻击者"></a>第三方攻击者</h3><p>​        利用用户A的签名识别密钥 ke ，任意给定y，任何人都可计算出：</p><script type="math/tex; mode=display">x'=y^{k_e}\  mod\  n</script><p>​        因而可以伪造对消息x的签名y（只需要保证x = x’，可以改变y的大小）</p><p>​        注意：文件x的具体值，伪造者无法控制。虽然可伪造（文件—签名）对，但这里的文件 x 可能是毫无意义的随机数。第三者无法伪造出想要的文件的签名。</p><p>​        如果用户A对文件x1和文件x2的签名分别为y1和y2，由于</p><script type="math/tex; mode=display">(x_1x_2)^d\ mod\ n= [(x_1^d\ mod\ n)(x_2^d\ mod\ n)]\ mod\ n</script><p>故任何第三方知道x1，x2，y1，y2，都可伪造出用户A对文件x1x2modn的签名y1y2modn</p><p>​        注意：文件x1x2modn 的具体值伪造者无法控制。</p><h3 id="对长文件的签名"><a href="#对长文件的签名" class="headerlink" title="对长文件的签名"></a>对长文件的签名</h3><p>​        若采取电码本方式逐块签名，则<strong>签名变长，签名速度慢</strong>；会遭遇<strong>替换攻击</strong>（重新组合和替换文件块）</p><p>​        解决方案：先将文件压缩成一个<strong>摘要</strong>，再对摘要签名。</p><p><img src="/images/data_sec/image-20211222192818516.png" alt="image-20211222192818516" style="zoom:80%;"></p><h2 id="DSA数字签名"><a href="#DSA数字签名" class="headerlink" title="DSA数字签名"></a>DSA数字签名</h2><p>​        安全性：基于有限域上的离散对数问题的难解性</p><h3 id="参数选取"><a href="#参数选取" class="headerlink" title="参数选取"></a>参数选取</h3><p>​        <strong>公开参数：p, q, g；公开密钥：y；保密密钥：x</strong></p><p>​        1、选取大素数p</p><script type="math/tex; mode=display">2^{L-1} <p< 2^L</script><p>其中L至少为512比特，并且是64的倍数；DSS推荐L ≤ 512 + 64×8 =1024 </p><p>​        2、选取素数q（q是p-1 的一个160比特的素数因子）</p><p>​        3、选取整数</p><script type="math/tex; mode=display">g=h^{\frac{p-1}{q}}\ mod\ p\quad (g>1,1<h<p-1)</script><p>​        4、随机选取整数x（0 &lt; x &lt; q）</p><p>​        5、计算</p><script type="math/tex; mode=display">y=g^x\ mod\ p</script><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>​        用户A对消息 m 进行签名，则A先选取一个小于 q 的随机数 k，计算</p><script type="math/tex; mode=display">\left\{\begin{aligned}\ r &= (g^k\ mod\ p)\ mod\ q \\\ s &= \ k^{-1}(H(m) + xr)\ mod\ q    \end{aligned}    \right.</script><p>​        其签名为（r，s）</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​        用户B计算</p><script type="math/tex; mode=display">\left\{\begin{aligned}\ w &= s^{-1}\ mod\ q \\\ u_1 &= H(m)w\ mod\ q \\\ u_2 &= rw\ mod\ q    \end{aligned}    \right.</script><script type="math/tex; mode=display">v= (g^{u_1} \cross y^{u_2}\ mod\ p)\ mod\ q</script><p>​        如果v = r，则B确认（r，s）是A对m的签名，否则签名无效。 </p><h2 id="ECDSA数字签名"><a href="#ECDSA数字签名" class="headerlink" title="ECDSA数字签名"></a>ECDSA数字签名</h2><p>​        其是在椭圆曲线上构建的数字签名算法</p><p>​        公开参数：F, E, P；公开密钥：Q；保密密钥：d</p><h3 id="参数选取-1"><a href="#参数选取-1" class="headerlink" title="参数选取"></a>参数选取</h3><p>​        1、构造有限域F；</p><p>​        2、生成域F上的椭圆曲线E</p><p>​        3、取椭圆曲线中的一个点P，要求点P要有大素数的阶q </p><p>​        4、选取一个整数d，计算Q = dP</p><h3 id="签名过程-1"><a href="#签名过程-1" class="headerlink" title="签名过程"></a>签名过程</h3><p>​        1、A秘密选取一个小于q的随机数k</p><p>​        2、A计算</p><script type="math/tex; mode=display">kp = (u,v)\\r =u\ mod\ q\\s = k^{-1}(H(m)+rd)\ mod\ q</script><p>​        则其签名为（r，s）</p><h3 id="验证过程-1"><a href="#验证过程-1" class="headerlink" title="验证过程"></a>验证过程</h3><p>​        1、验收方计算</p><script type="math/tex; mode=display">w = s^{-1}\ mod\ q\\u_1 = H(m)w\ mod\ q\\u_2 = rw\ mod\ q</script><p>​        如果</p><script type="math/tex; mode=display">（u,v） = u_1P + u_2Y</script><p>​        则B确认（r、s）是A对m的签名，否则签名无效</p><h1 id="十一、Hash函数"><a href="#十一、Hash函数" class="headerlink" title="十一、Hash函数"></a>十一、Hash函数</h1><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>​        哈希函数（Hash function）又称散列算法、散列函数，是一种从任何一种数据中创建小的数字“指纹”的方法。 散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>​        1、数据完整性检验     2、用于数字签名    3、密钥推导    4、伪随机数生成</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>​        输入长度可变：对任何长度的输入x都适用</p><p>​        输出长度固定：对任何长度的输入x，输出z都是固定长度</p><p>​        效率：计算复杂度低</p><p>​        抗原像攻击（单向性）：对于给定输出y，不可能找到对应的输入x</p><p>​        抗第二原像攻击（抗弱碰撞性、弱无碰撞性）：对于给定的x_1，找到满足h(x_1) = h(x_2)的x_2是不可行的</p><p>​        抗碰撞攻击（抗强碰撞性、强无碰撞性）：找到满足ℎ(x_1) = ℎ(x_2)的偶对x_1 = x_2，在计算上是不可行的</p><p>​    <strong>若一个Hash函数具有强无碰撞性，则一定具有弱无碰撞性！若一个Hash函数不具有弱无碰撞性，则一定不具有强无碰撞性！</strong></p><h2 id="自由起始碰撞攻击"><a href="#自由起始碰撞攻击" class="headerlink" title="自由起始碰撞攻击"></a>自由起始碰撞攻击</h2><h3 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h3><p>​        Step1  随机选取N个不同的报文m1，m2……mN</p><p>​        Step2 计算这N个报文的Hash值,得到集合</p><script type="math/tex; mode=display">S=\{(m_k, \ H(m_k)):  k = 1,2,\cdots, N\}</script><p>​        Step3 根据 H(mk) 的大小，对集合S利用快速排序算法重新排序，在排序过程中，如果找到了<strong>使 H(mk)= H(mt) 的两个不同消息mk和mt</strong>，就将(mk,mt)作为结果输出，算法终止；如果找不到，就报告碰撞攻击失败，算法终止。</p><h3 id="成功率分析"><a href="#成功率分析" class="headerlink" title="成功率分析"></a>成功率分析</h3><p><img src="/images/data_sec/image-20211223131955455.png" alt="image-20211223131955455" style="zoom: 80%;"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​        碰撞攻击成功率 = Pr[N个报文中至少存在一对消息，使得Hash值相同] = 1- Pr[N个报文的Hash值都不同]</p><p><img src="/images/data_sec/image-20211223132248482.png" alt="image-20211223132248482" style="zoom:80%;"></p><p><img src="/images/data_sec/image-20211223132343431.png" alt="image-20211223132343431" style="zoom:80%;"></p><p><img src="/images/data_sec/image-20211223132614738.png" alt="image-20211223132614738" style="zoom:80%;"></p><p><img src="/images/data_sec/image-20211223135815589.png" alt="image-20211223135815589" style="zoom:80%;"></p><h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><h3 id="MD强化技术"><a href="#MD强化技术" class="headerlink" title="MD强化技术"></a>MD强化技术</h3><p>​        将消息M = (M1,M2,…,Mn)的最后一个分组Mn设置为原始消息的长度，这个过程称为MD强化</p><p>​        消息M = (M1,M2,…,Mn)，H0是初始值，Hi=E(Hi-1,Mi), i=1,2,…,n，最后得到的Hn是消息M的Hash值</p><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>​        对任意输入的长度均输出一个128位的输出，主循环一次可以处理512比特的分组，最后输出128比特</p><h3 id="初始化处理"><a href="#初始化处理" class="headerlink" title="初始化处理"></a>初始化处理</h3><p>​        在原始消息的二进制表示之后<strong>先填入一个1</strong>，在最低位64比特填入原始消息长度的二进制表示，中间全部补0，使填充后的消息长度恰好是<strong>512比特或512的整数倍比特</strong>。（如果消息长度大于2^64，则在最低的64比特位填入消息长度取模2^64后的二进制表示。）</p><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>​        我们将每个512比特的消息分成16各组，每组32位，假设我们共有t个比特快，那么对于 i = 0至 t -1,依次执行以下步骤：</p><p><img src="/images/data_sec/QQ截图20211223141550.png" style="zoom:80%;"></p><p>​        其中，step3—step6中每轮采取以下的函数进行运算：</p><p><img src="/images/data_sec/image-20211223141236937.png" alt="image-20211223141236937" style="zoom:80%;"></p><p>​        具体的每轮实现格式如下，具体每一轮的i和s都是固定的（有计算方法但是过于复杂，默认为固定），每次以为完之后都对当前处于第一的位置的值进行刷新，其中第一轮的值为固定的初始值，是4个32比特的初始向量：</p><div class="table-container"><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">初始向量</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">0x01234567</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">0x89abcdef</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">0xfedcba98</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">0x76543210</td></tr></tbody></table></div><p><img src="/images/data_sec/image-20211223142755141.png" alt="image-20211223142755141" style="zoom:80%;"></p><p><img src="/images/data_sec/image-20211223143100539.png" alt="image-20211223143100539" style="zoom:80%;"></p><p><img src="/images/data_sec/image-20211223143107967.png" alt="image-20211223143107967" style="zoom:80%;"></p><p><img src="/images/data_sec/image-20211223143115381.png" alt="image-20211223143115381" style="zoom:80%;"></p><h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p><img src="/images/data_sec/image-20211223144256314.png" alt="image-20211223144256314" style="zoom:67%;"></p><h3 id="安全要求"><a href="#安全要求" class="headerlink" title="安全要求"></a>安全要求</h3><p>​        1、未知密钥时不能构造消息-认证码的一个匹配对</p><p>​        2、未知密钥时不能将一个消息—认证码的匹配对修改为另一个消息—认证码的匹配对。</p><h3 id="HMAC消息认证码"><a href="#HMAC消息认证码" class="headerlink" title="HMAC消息认证码"></a>HMAC消息认证码</h3><p><img src="/images/data_sec/image-20211223144442824.png" alt="image-20211223144442824" style="zoom:67%;"></p><p>​        <strong>共调用Hash函数Hash两次</strong></p><script type="math/tex; mode=display">HMAC(m) = Hash_{k_2} (Hash_{k_1}(m))</script><h1 id="十二、AI安全"><a href="#十二、AI安全" class="headerlink" title="十二、AI安全"></a>十二、AI安全</h1><h3 id="对抗样本"><a href="#对抗样本" class="headerlink" title="对抗样本"></a>对抗样本</h3><p>​        2013年发现了机器学习的对抗样本</p><p>​        原图像（正确分类）+ 精心设计的噪声→对抗样本（被错误分类）</p><h4 id="AI安全需求"><a href="#AI安全需求" class="headerlink" title="AI安全需求"></a>AI安全需求</h4><p>​        可靠性：无污染的训练过程和测试过程</p><p>​        稳定性：模型应具有足够的鲁棒性以处理所有<strong>噪声的输入</strong></p><p>​        隐私性：用户看不到有关该模型的所有信息</p><h3 id="现实环境"><a href="#现实环境" class="headerlink" title="现实环境"></a>现实环境</h3><p>​        可靠性：数据集中的信息未必是可信的，训练中的人员也未必都可信（恶意标记的情况）</p><p>​        稳定性：机器学习复杂性强，特征仅有训练集数据学习而来，很难保证模型能够处理噪声的输入</p><p>​        隐私性：随着分类器被不断查询，分类器的相关信息，包括模型参数甚至训练数据，都面临着泄漏的风险。</p><h3 id="AI攻击手段"><a href="#AI攻击手段" class="headerlink" title="AI攻击手段"></a>AI攻击手段</h3><p>​        <strong>数据中毒（恶意标记）、对抗样本（噪声干扰）、逆向工程（反推出模型参数信息）</strong></p><h2 id="AI攻击目标分类"><a href="#AI攻击目标分类" class="headerlink" title="AI攻击目标分类"></a>AI攻击目标分类</h2><h3 id="因果攻击"><a href="#因果攻击" class="headerlink" title="因果攻击"></a>因果攻击</h3><p>​        更改学习的分类模型</p><p>​        有针对性的攻击：确保分类器将特定的数据样本分配给选定的类别。（例如让某张8被分类器识别为5）</p><p>​        无差别的攻击：在不确保分配特定目标类的情况下，仅试图寻求对特定数据样本更改做出的决定。（例如让某张8被识别错误）</p><p>​        可用性攻击：通过将分类器的准确性降低到无法接受的低水平来使其无法使用。（例如让分类器识别尽可能多出错）</p><h3 id="探索性攻击"><a href="#探索性攻击" class="headerlink" title="探索性攻击"></a>探索性攻击</h3><p>​        不更改学习的模型，而是探索学习有关模型或训练数据集参数的信息。</p><h3 id="AI攻击入口分类"><a href="#AI攻击入口分类" class="headerlink" title="AI攻击入口分类"></a>AI攻击入口分类</h3><h4 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><p>​    训练阶段：提供错误的训练样本</p><p>​    测试阶段：提供带攻击者设计噪声的样本，通过查询获取模型信息</p><h4 id="物理环境"><a href="#物理环境" class="headerlink" title="物理环境"></a>物理环境</h4><p>​        在现实世界破坏样本：如对被感知物体贴标签</p><p>​        从物理信息获取模型信息：如通过模型处理时间推测模型层数</p><h2 id="AI安全分类"><a href="#AI安全分类" class="headerlink" title="AI安全分类"></a>AI安全分类</h2><p>​        机密性：AI模型是否可以保留其参数和数据集的隐私性，例如逆向工程攻击（模型参数窃取，训练数据窃取</p><p>​        完整性：AI模型的工作过程是否受到干扰，例如对抗性样本攻击（设计噪声，破坏了正常输入的样本）</p><p>​        可用性：AI模型是否正常运行且运行稳定，例如对抗性样本攻击（面对对抗性样本时，模型输出有误），例如数据中毒攻击（可以使AI模型效果下降）</p><h5 id="攻击者模型"><a href="#攻击者模型" class="headerlink" title="攻击者模型"></a>攻击者模型</h5><p><img src="/images/data_sec/image-20211223150133436.png" alt="image-20211223150133436" style="zoom:67%;"></p><h3 id="数据中毒攻击"><a href="#数据中毒攻击" class="headerlink" title="数据中毒攻击"></a>数据中毒攻击</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>​        攻击者通过将<strong>中毒的样本</strong>引入训练/验证/测试集造成的因果攻击。</p><p>​        中毒来源：可以是来自该领域，有针对性的或无差别错误标记的样本，或是被修改的样本（不易察觉），或者非该领域的典型样本（如将鸟的图片放入手写数字识别训练集）。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​        错误的或是中毒的样本会使分类器<strong>学到错误的特征</strong>，从而改变了分类器模型。</p><h4 id="错误特征的不同表现："><a href="#错误特征的不同表现：" class="headerlink" title="错误特征的不同表现："></a>错误特征的不同表现：</h4><p>​        <strong>传统分类器</strong>：如支持向量机，会因为中毒的样本导致分类器分类错误，产生性能下降，因此适合实现可用性攻击。</p><p>​        <strong>深度神经网络</strong>：深度神经网路有更强的复杂性，因此可以容忍一定的中毒样本，但会<strong>记忆这样的中毒样本</strong></p><p>​        因此可以以此完成<strong>后门攻击</strong>（有针对性的攻击），例如：将加入触发器的有毒样本作为训练集（如将带一个小点的6标记为1），训练后，使用时不带小点的6正常识别，带点的6识别为1，这样的小点就称为触发器或后门</p><h3 id="对抗攻击"><a href="#对抗攻击" class="headerlink" title="对抗攻击"></a>对抗攻击</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p>​        指攻击者通过输入经过<strong>不为人所察觉</strong>的扰动后的样本，使得分类模型决策发生本不应该发生的变化。英文为“adversarial machine learning”，对抗样本称为“adversarial samples”。<br>​        又被称为<strong>测试阶段逃逸攻击</strong>（evasion attack），是深度学习攻击中研究最广泛的一类攻击。例如为人脸添加一定的噪声，在人难以分辨的情况下，使得分类模型误分类。<br>​        与数据中毒攻击类似，这样的攻击可以是有导向性的，也可以是无导向性的。近来研究表示，甚至能够在现实环境中构建对抗样本以干扰分类器。</p><h4 id="方法与知识"><a href="#方法与知识" class="headerlink" title="方法与知识"></a>方法与知识</h4><p>​        对抗样本攻击，通常在样本上施加一定的扰动，这样的扰动不是任意的，而是根据目标模型精心设计的</p><p>​        对抗样本攻击，要求攻击者对模型有一定了解，属于<strong>灰盒或白盒</strong>攻击，如果模型为黑盒模型应想办法转化为灰/白盒</p><h4 id="与后门攻击的异同"><a href="#与后门攻击的异同" class="headerlink" title="与后门攻击的异同"></a>与后门攻击的异同</h4><p>​        相同点：样本都有特定的处理，都可以导致目标分类器出错。</p><p>​        不同点：<strong>后门攻击在训练阶段</strong>引入带后门的样本，改变了原有模型，扰动可自己指定；<strong>对抗样本攻击发生在测试阶段</strong>，利用而不改变原有模型，设计扰动需模型信息。</p><h4 id="主要攻击算法"><a href="#主要攻击算法" class="headerlink" title="主要攻击算法"></a>主要攻击算法</h4><p>​        简单界约束的L-BFGS、快速梯度符号法、投影梯度下降法</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>​        像素改变下图象识别、打印的眼镜框欺骗人脸识别系统、贴纸干扰分类器的分类、3D物体欺骗特斯拉自动驾驶的激光雷达系统，使障碍物不被检测、图像缩放算法</p><h3 id="逆向工程攻击"><a href="#逆向工程攻击" class="headerlink" title="逆向工程攻击"></a>逆向工程攻击</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p>​        通过查询一个分类器，以了解它的决策规则或它的训练集（即对数据隐私的攻击）主要分为以下三类：模型推断攻击、数据重构攻击、数据推测攻击</p><h5 id="模型推断攻击-model-inference-attack"><a href="#模型推断攻击-model-inference-attack" class="headerlink" title="模型推断攻击(model inference attack)"></a><strong>模型推断攻击</strong>(model inference attack)</h5><p>​        针对<strong>模型参数、结构</strong>等，试图构建与目标模型决策类似的模仿型</p><p>​        基本做法：不断查询：将样本输入模型，并获取来自模型的结果。</p><p>​        原理：每次查询事实上就是获得一个样本，足够多的样本可以形成训练集用于训练自己的模型。</p><p>​        与对抗性样本攻击的关系：对抗性样本攻击需要对模型有一定的了解。黑盒场景下，可以通过模型重构来搭建本地的模型，用于对抗性样本攻击，称为代理模型。攻击者在<strong>代理模型上设计对抗性样本</strong>，并试图迁移至目标模型。</p><h5 id="数据重构攻击-model-inverse-attack"><a href="#数据重构攻击-model-inverse-attack" class="headerlink" title="数据重构攻击(model inverse attack)"></a><strong>数据重构攻击</strong>(model inverse attack)</h5><p>​        从模型预测结果中提取和训练数据有关的信息，获取训练集隐私的攻击，具体指重构训练集中的样本</p><h5 id="数据推测攻击-如membership-inference-attack"><a href="#数据推测攻击-如membership-inference-attack" class="headerlink" title="数据推测攻击(如membership inference attack)"></a><strong>数据推测攻击</strong>(如membership inference attack)</h5><p>​        获取训练集隐私的攻击，具体指判断某个样本<strong>是否属于训练集</strong>，如艾滋病患者数据集</p><p><img src="/images/data_sec/QQ截图20211223162009.png" alt></p><h3 id="数据中毒防御"><a href="#数据中毒防御" class="headerlink" title="数据中毒防御"></a>数据中毒防御</h3><h4 id="主要做法"><a href="#主要做法" class="headerlink" title="主要做法"></a>主要做法</h4><p>​        训练集消毒，试图去掉有毒样本，然后进行分类器学习。</p><p>​        特征选择或降维，去除异常样本</p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>​        如果攻击者具有防御知识，可以更好设计数据中毒攻击，规避防御并降低分类准确性。</p><p>​        如果没有攻击者，分类准确率会降低。</p><h3 id="对抗样本防御"><a href="#对抗样本防御" class="headerlink" title="对抗样本防御"></a>对抗样本防御</h3><h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><p>​        在学习期间使用经过<strong>修改的训练集</strong>，或者在测试期间使用经过修改的输入，例如对抗训练等（把对抗性样本一起训练）</p><p>​        修改网络，例如通过添加更多的层/网络，更改激活功能等</p><p>​        在对难分辨的示例进行分类时，使用外部模型作为补充。 例如，Defense-GAN等。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>​        利用对抗样本训练模型的鲁棒性：PGD算法对抗训练</p><p>​        异常检测：基于从DNN内部得出的权重信息的异常检测，将异常检测器作为一个前置的网络结构<br>未检测到异常（攻击）才对图像进行分类</p><p>​        以毒攻毒：用新的干扰破坏精心设计的干扰</p><p>​        返璞归真：使用生成器把处理后的图像还原</p><h3 id="逆向工程防御"><a href="#逆向工程防御" class="headerlink" title="逆向工程防御"></a>逆向工程防御</h3><p>​        模型提供者可以减少或者修改输出的信息，提高攻击者的攻击难度（不能根源解决问题）例如，只给出Top-K标签，或是不给出置信度。</p><h3 id="AI助力安全"><a href="#AI助力安全" class="headerlink" title="AI助力安全"></a>AI助力安全</h3><p>​        AI作为工具，可以应用在安全问题的各个领域</p><p>​        检测：如检测恶意软件、垃圾邮件、网络入侵检测等</p><p>​        认证：用户认证，如刷脸、语音解锁等</p><p>​        设计加密算法</p>]]></content>
    
    
    <categories>
      
      <category>cs learning</category>
      
      <category>Data security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network points</title>
    <link href="/2022/03/08/a/"/>
    <url>/2022/03/08/a/</url>
    
    <content type="html"><![CDATA[<p>我们将从这篇笔记中学到计算机网络自上而下的结构体系，对于整体网络有清楚的认识</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h1><h3 id="两大应用程序体系结构"><a href="#两大应用程序体系结构" class="headerlink" title="两大应用程序体系结构"></a>两大应用程序体系结构</h3><h4 id="•-CS-client-server-architeture-客户-服务器体系结构"><a href="#•-CS-client-server-architeture-客户-服务器体系结构" class="headerlink" title="•   CS   client-server architeture  客户-服务器体系结构"></a><strong>•   CS   client-server architeture  客户-服务器体系结构</strong></h4><p>​    有一个总是打开的<strong>服务器</strong>主机，服务其他<strong>客户</strong>的主机的请求</p><p>​    在进程中发起通信的进程被叫做客户，等待联系的进程被叫做服务器</p><p>​    进程通过<strong>套接字</strong>的软件接口发送和接收报文</p><p>​    套接字是应用程序进程和<strong>运输层协议</strong>之间的接口，也被称为应用程序和网络之间的<strong>API</strong></p><p>​    表示进程需要定义的两种信息：主机的<strong>IP地址</strong>，主机的<strong>端口号</strong></p><h4 id="•-P2P-Peer-to-peer-architecture-P2P体系结构"><a href="#•-P2P-Peer-to-peer-architecture-P2P体系结构" class="headerlink" title="•   P2P   Peer-to-peer architecture  P2P体系结构"></a><strong>•   P2P   Peer-to-peer architecture  P2P体系结构</strong></h4><p>​    应用程序在间断连接的主机对之间直接通信，这些主机被称为<strong>对等方</strong></p><h4 id="Bittorrent"><a href="#Bittorrent" class="headerlink" title="Bittorrent"></a>Bittorrent</h4><p>​    参与一个特定文件分发的所有对等方的集合被称为一个洪流，一个洪流中的所有对等方彼此下载等长度的块</p><h4 id="tit-for-tat实现"><a href="#tit-for-tat实现" class="headerlink" title="tit-for-tat实现"></a>tit-for-tat实现</h4><p>​    当前主机A将选择能够以最高速率提供数据的邻居给出优先权，当此主机随机发送时，其发送速率可能也达到某目的主机B选择的最高速率的集合中，那么目的主机B将会向A发送数据，若B发送速率也满足最高速率之一的条件，B也将成为A的优先邻居之一。以此类推，对等方能以趋向于彼此的协调的速率上载</p><h3 id="•-HTTP-HyperText-Transfer-Protocol-超文本传输协议"><a href="#•-HTTP-HyperText-Transfer-Protocol-超文本传输协议" class="headerlink" title="•   HTTP   HyperText Transfer Protocol 超文本传输协议"></a>•   <strong>HTTP   HyperText Transfer Protocol</strong> <strong>超文本传输协议</strong></h3><p>​    以TCP为支撑运输协议，正确快速地传输超文本文档</p><h4 id="持续连接与非持续连接"><a href="#持续连接与非持续连接" class="headerlink" title="持续连接与非持续连接"></a>持续连接与非持续连接</h4><p>​    HTTP既能够使用持续连接【每个请求或响应由单独的TCP发送】，也能够使用非持续连接【每个请求或响应由单独的TCP发送】</p><p>​    非持续连接：单次耗时——两个RTT时间（一次TCP连接和一次TCP请求）和传输文件的时间</p><p>​    持续连接耗时：总耗时——一个RTT（第一次TCP连接）加上n个单次耗时——一个RTT加上文件传输的时间</p><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>​    请求行：方法字段：GET、POST、HEAD、PUT、DELETE等</p><p>​                    URL字段：请求对象的标识</p><p>​                    HTTP版本字段</p><p>​    首部行：Host：请求的主机名</p><p>​                    Connection：发送完后关闭TCP连接</p><p>​                    User-Agent：产生请求的浏览器类型</p><p>​                    Accept-language：客户端可识别的语言类型</p><p>​    实体体：当为GET方法时，实体体为空</p><p>​                    当为POST方法时，实体体为用户输入值（通常是提交表单操作）</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p>​    初始状态行：协议版本字段</p><p>​                            状态码和相应状态信息：200 OK、301 Moved Permanently 、404 Not Found 等</p><p>​    首部行： Connection：发送完后关闭TCP连接</p><p>​    ·                Date：相应日期和时间</p><p>​                    Server：服务器</p><p>​                    Last-Modified：对象创建或最后修改的时间</p><p>​                    Content-length：发送对象的字节数</p><p>​                    Content-type：实体体中对象的格式，eg html</p><p>​    实体体</p><h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><p>​    浏览器创建一个到Web缓存的TCP连接，向Web缓存发送HTTP请求：</p><p>​            若本地有副本，则响应HTTP并返回该对象</p><p>​            若本地没有副本，则创建一个到初始服务器的TCP连接，向初始服务器发送HTTP请求，接收到初始服务器响应后进行本地缓存并向浏览器返回结果</p><p>​    Web缓存既是服务器也是客户</p><p>​            服务器：接受浏览器的请求并返回响应</p><p>​            客户：向初始服务器发送请求并接受响应</p><p>​    条件GET：通过If-modified-since判断缓存中的对象是否是最新的</p><p>​                      若自指定日期后对该对象修改过，才发送该对象，否则条件GET的响应报文实体为空</p><h3 id="•-SMTP-Simple-Mail-Transfer-Protocol-简单邮件传输协议"><a href="#•-SMTP-Simple-Mail-Transfer-Protocol-简单邮件传输协议" class="headerlink" title="•   SMTP   Simple Mail Transfer Protocol 简单邮件传输协议"></a>•   <strong>SMTP   Simple Mail Transfer Protocol</strong> <strong>简单邮件传输协议</strong></h3><p>​    电子邮件系统的组成：<strong>用户代理</strong>、<strong>邮件服务器</strong>、<strong>简单邮件传输协议</strong></p><p>​    用于发送方发送邮件至发送方的邮件服务器</p><p>​    以及从发送方的邮件服务器发送邮件至接收方的邮件服务器</p><p>​    SMTP的报文格式：7比特ASCII码格式</p><h3 id="•-POP3-Post-Office-Protocol-–-version-3-第三版邮局协议"><a href="#•-POP3-Post-Office-Protocol-–-version-3-第三版邮局协议" class="headerlink" title="•   POP3   Post Office Protocol – version 3 第三版邮局协议"></a>•   <strong>POP3   Post Office Protocol – version 3</strong> <strong>第三版邮局协议</strong></h3><h3 id="•-IMAP-Internet-Message-Access-Protocol-因特网邮件访问协议"><a href="#•-IMAP-Internet-Message-Access-Protocol-因特网邮件访问协议" class="headerlink" title="•   IMAP   Internet Message Access Protocol  因特网邮件访问协议"></a>•   <strong>IMAP   Internet Message Access Protocol</strong>  <strong>因特网邮件访问协议</strong></h3><p>​    此二者用于从接收方的服务器发送邮件至接收方</p><h3 id="•-DNS-Domain-Name-System-域名系统"><a href="#•-DNS-Domain-Name-System-域名系统" class="headerlink" title="•   DNS    Domain Name System 域名系统"></a>•   <strong>DNS    Domain Name System</strong> <strong>域名系统</strong></h3><p>​    <strong>运行在UDP之上，速度快，避免创建时延</strong></p><p>​    进行主机名到IP地址的转换，可用于寻找目的web的IP地址（HTTP需要）</p><p>​    DNS通过分布式数据库存储IP地址和主机名的集合</p><p>​    DNS功能：IP地址转换、主机别名、邮件服务器别名、负载分配</p><p>​    分布式层次查找：根DNS服务器、顶级DNS服务器、权威DNS服务器、本地DNS服务器</p><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>​        源主机向他所在的本地DNS服务器发送DNS查询报文，本地DNS服务器将其转发到根DNS服务器，根据主机名的层层拆分，不断向根DNS服务器、顶级DNS服务器、权威DNS服务器查询主机名，最终确定主机名直接向目的主机发送IP查询，获取到IP地址。DNS既可以递归查询，也可以迭代查询</p><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>​        如果一台DNS服务器缓存了某IP主机地址对，查询到该服务器时可直接返回IP地址</p><h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>​        首部区域12字节：标识符：16比特，标识该查询以匹配请求与回答</p><p>​                                    标志：指出是查询报文（0）还是回答报文（1）</p><p>​                                    数量字段：说明数据区域出现的数量</p><p>​        问题区域：包含正在查询的信息，名字字段+类型字段</p><p>​        回答区域：包含最初请求的名字的资源记录</p><p>​        权威区域：其他权威服务器的记录</p><p>​        附加区域：附加的有用的信息</p><h3 id="•-DASH-Dynamic-Adaptive-Streaming-over-HTTP-经HTTP的动态适应性流"><a href="#•-DASH-Dynamic-Adaptive-Streaming-over-HTTP-经HTTP的动态适应性流" class="headerlink" title="•   DASH   Dynamic Adaptive Streaming over HTTP  经HTTP的动态适应性流"></a><strong>•   DASH   Dynamic Adaptive Streaming over HTTP  经HTTP的动态适应性流</strong></h3><p>​    客户动态的请求来自不同版本（速率不同）的数据块，根据可用带宽选择合适的速率版本的块</p><h3 id="•-CDN-Content-Distribution-Network-内容分发网"><a href="#•-CDN-Content-Distribution-Network-内容分发网" class="headerlink" title="•   CDN   Content Distribution Network  内容分发网"></a><strong>•   CDN   Content Distribution Network  内容分发网</strong></h3><p>​    使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p><p>​    两种服务器安置策略：</p><p>​    深入：靠近端用户部署，减少端用户和CDN集群之间的链路和路由器的数量</p><p>​    邀请做客：在关键位置建造大集群，通常将集群放置在因特网交换点</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><strong>运输层</strong></h1><p><strong>为应用程序之间提供端到端的逻辑通信</strong></p><p><img src="/images/cs_net/7142610-8c83a040e6aebd52.png" alt></p><h3 id="•-demultiplexing-多路分解"><a href="#•-demultiplexing-多路分解" class="headerlink" title="•   demultiplexing    多路分解"></a>•   demultiplexing    多路分解</h3><p>​    将运输层报文段中的数据交付多艘正确的套接字</p><h3 id="•-multiplexing-多路复用"><a href="#•-multiplexing-多路复用" class="headerlink" title="•   multiplexing    多路复用"></a>•   multiplexing    多路复用</h3><p>​    从原主机不同套接字收集数据并封装生成报文段，然后将报文段传递到网络层</p><h2 id="•-套接字"><a href="#•-套接字" class="headerlink" title="•   套接字"></a>•   套接字</h2><p>​    套接字有唯一的标识符；每个报文段有特殊字符指示到哪个套接字</p><p>​    即源端口号字段和目的端口号字段</p><p>​    UDP套接字：二元组，目的IP地址+目的端口号</p><p>​            当目的IP地址和目的端口号相同时将被分到相同的进程</p><p>​    TCP套接字：四元组，源IP地址+源端口号+目的IP地址+目的端口号</p><p>​            当源IP地址或源端口号不同时将被分到两个不同的进程</p><h2 id="•-IP地址和端口号"><a href="#•-IP地址和端口号" class="headerlink" title="•   IP地址和端口号"></a>•   IP地址和端口号</h2><p>​    一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的</p><p>​    无论是客户端还是服务器端，都对应一个或多个特定的端口号，每个端口对应一个唯一的程序</p><p>​    ftp：23，telnet：23，smtp：25，dns：53，http：80，https：443</p><h2 id="•-UDP-User-Datagram-Protocol-用户数据报协议"><a href="#•-UDP-User-Datagram-Protocol-用户数据报协议" class="headerlink" title="•   UDP    User Datagram Protocol   用户数据报协议"></a>•   <strong>UDP    User Datagram Protocol</strong>   <strong>用户数据报协议</strong></h2><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>​        立即发送</p><p>​        无连接：发送方和接收方的运输层实体没有握手的过程，不会引入建立连接的时延</p><p>​        不可靠服务：不能保证数据到达接收端，到达也可能是错误、乱序的</p><p>​        能发现差错但无法恢复：观察<strong>检验和</strong>的比特是否发生了改变，但没有差错恢复能力，智能丢弃受损的报文段</p><p>​        分组首部开销小：8字节</p><p>​        没有拥塞控制</p><h4 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h4><p>​        首部四个字段：源端口号、目的端口号、长度、校验和</p><h2 id="•-可靠传输协议"><a href="#•-可靠传输协议" class="headerlink" title="•   可靠传输协议"></a>•   可靠传输协议</h2><h3 id="rdt1-0——经完全可靠信道的传输"><a href="#rdt1-0——经完全可靠信道的传输" class="headerlink" title="rdt1.0——经完全可靠信道的传输"></a>rdt1.0——经完全可靠信道的传输</h3><h3 id="rdt2-0——经由比特差错新到的传输"><a href="#rdt2-0——经由比特差错新到的传输" class="headerlink" title="rdt2.0——经由比特差错新到的传输"></a>rdt2.0——经由比特差错新到的传输</h3><p>​            <strong>ARQ    Automatic Repeat-reQuest    自动重传请求</strong></p><p>​            差错检测：检测是否产生比特错误</p><p>​            接收方反馈：接受者发送肯定确认ACK，或否定确认NAK</p><p>​            重传：接收方收到有差错的分组，发送方重传</p><h3 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h3><p>​            rdt2.0没有考虑ACK或NAK的受损</p><p>​            当收到错误的ACK或NAK分组后，发送方进行重传（此时需解决冗余问题）</p><p>​            <strong>添加分组序号</strong>，接收方检查当前分组是否经过重传</p><h3 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h3><p>​            取消NAK设定，改成发送<strong>冗余ACK</strong></p><p>​            <strong>累计确认</strong></p><p>​            <strong>发送方需确认ACK的序号，判断是当前分组的ACK（成功无差错）或是已经接受到的最后一个正确分组的ACK（冗余ACK，此次分组有错）</strong></p><h3 id="rdt3-0——经由比特差错的丢包信道的传输"><a href="#rdt3-0——经由比特差错的丢包信道的传输" class="headerlink" title="rdt3.0——经由比特差错的丢包信道的传输"></a>rdt3.0——经由比特差错的丢包信道的传输</h3><p>​            <strong>倒计数定时器</strong>，设定超时间隔</p><p>​            在超时间隔内若未收到ACK，则进行重传（即使只是ACK延迟，发送的冗余数据也可由序号解决）</p><p>​            发送分组开始时启动定时器，当超过时间间隔需要重传，重新启动定时器</p><p>​            若ACK有延迟在超时后才会到达，只要在新的超时间隔内收到，那么之后的小于该ACK的报文均不会重传，因为<strong>累计确认</strong></p><h3 id="•-Pipelined-Protocol-流水线协议"><a href="#•-Pipelined-Protocol-流水线协议" class="headerlink" title="•  Pipelined Protocol    流水线协议"></a>•  Pipelined Protocol    流水线协议</h3><p>​    区别于停等协议，可以让传送端同时传送多个封包不需等待确认</p><h2 id="•-GBN-Go-Back-N-回退N步"><a href="#•-GBN-Go-Back-N-回退N步" class="headerlink" title="•   GBN    Go-Back-N    回退N步"></a>•   <strong>GBN    Go-Back-N</strong>    <strong>回退N步</strong></h2><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h4><p><img src="/images/cs_net/QQ图片20210622124727.jpg" style="zoom: 33%;"></p><p>​    发送方：    </p><p>​        上层调用：检查当前窗口是否已满，是否有n个已发送但还未确认的分组</p><p>​        收到ACK：累计确认的方式</p><p>​        超时事件：一旦超时重传所有已发送但还未确认的分组</p><p>​    接收方：</p><p>​        <strong>丢弃所有失序分组</strong>，丢弃后返回最大已确认序号的ACK（符合累计确认）</p><h4 id="•-SR-Selective-Repeat-选择重传"><a href="#•-SR-Selective-Repeat-选择重传" class="headerlink" title="•   SR   Selective Repeat    选择重传"></a>•   <strong>SR   Selective Repeat</strong>    <strong>选择重传</strong></h4><p>​    <strong>逐个确认</strong></p><p>​    发送方仅重传那些丢失或受损的分组，避免不必要的重传</p><p>​    接收方若收到以前没收到过的序号的分组，将他们缓存；若等于当前基序号，则将它以及之前缓存的多个有序的分组一并交付给上层</p><p><img src="/images/cs_net/QQ图片20210622124739.jpg" style="zoom:50%;"></p><p>​    窗口大小规则：<strong>窗口长度必须小于或等于序号空间大小的一半</strong></p><h2 id="•-TCP-Transmission-Control-Protocol-传输控制协议"><a href="#•-TCP-Transmission-Control-Protocol-传输控制协议" class="headerlink" title="•   TCP    Transmission Control Protocol    传输控制协议"></a>•   <strong>TCP    Transmission Control Protocol</strong>    <strong>传输控制协议</strong></h2><h3 id="面向连接——三次握手："><a href="#面向连接——三次握手：" class="headerlink" title="面向连接——三次握手："></a>面向连接——三次握手：</h3><p>​            第一次：客户发送不包含应用层数据的报文段，将SYN位置为1，包含一个初始序号，<strong>SYN报文段</strong></p><p>​            第二次：服务器接收后返回允许连接的报文段，附带有服务器的初始序号，<strong>SYNACK报文段</strong></p><p>​            第三次：客户对允许连接进行确认，客户和服务器的初始序号加1，SYN位被置为0</p><p>​            意义：防止已失效的报文段。请求报文可能在某个失效时间到达服务器，如没有握手过程，服务器会默认有一个请求（实际上没有），服务器将一直等待</p><h3 id="拥塞控制——对路由而言："><a href="#拥塞控制——对路由而言：" class="headerlink" title="拥塞控制——对路由而言："></a>拥塞控制——对路由而言：</h3><h4 id="拥塞的代价"><a href="#拥塞的代价" class="headerlink" title="拥塞的代价"></a>拥塞的代价</h4><p>​            当分组速率到达链路容量时，分组经历巨大的排队时延</p><p>​            发送方必须重传以弥补因缓存溢出而丢弃的分组</p><p>​            在较大时延时不必要的重传和转发</p><p>​        因此一旦产生丢包意味着拥塞发生，应降低发送方的发送速率</p><h4 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h4><p>​            慢启动：发送方希望快速找到可用带宽的数量，拥塞窗口（cwnd）从1开始，每个RTT内2的指数级增加，一旦到达threshold转入拥塞避免模式</p><p>​            拥塞避免：每个RTT只将cwnd的值增加一个MSS</p><p>​            3个冗余的ACK的丢包：cwnd的值变为一半，threshold也变为一半</p><p>​            超时指示的丢包：cwnd降为1，threshold变为一半</p><h4 id="流量控制——对接收方而言"><a href="#流量控制——对接收方而言" class="headerlink" title="流量控制——对接收方而言"></a>流量控制——对接收方而言</h4><p>​            消除缓存溢出的可能性</p><p>​            接收方告知发送方缓存中还有多少可用的空间，应保证发送方发送到连接上但还未被确认的数据小于可用缓存</p><h4 id="可靠服务"><a href="#可靠服务" class="headerlink" title="可靠服务"></a>可靠服务</h4><p>​            累计确认，rdt3.0的模式</p><h4 id="差错恢复"><a href="#差错恢复" class="headerlink" title="差错恢复"></a>差错恢复</h4><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p>​    源端口号、目的端口号</p><p>​    32字节的序号字段和32字节的确认号字段：用来保证可靠传输</p><p>​    16比特接收窗口字段：用于流量控制</p><p>​    首部长度：通常为20字节</p><p>​    标志字段：ACK、RST、SYN、FIN、PSH、URG</p><p><img src="/images/cs_net/QQ截图20210621210001.png" style="zoom:80%;"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h1><h3 id="•-两个相互作用的部分-数据平面和控制平面"><a href="#•-两个相互作用的部分-数据平面和控制平面" class="headerlink" title="•  两个相互作用的部分    数据平面和控制平面"></a>•  两个相互作用的部分    数据平面和控制平面</h3><p>​        数据平面：从输入链路想输出链路转发数据报</p><p>​        控制平面：协调每个路由器的转发，选择路径进行传送</p><h3 id="•-两大核心作用-转发和路由"><a href="#•-两大核心作用-转发和路由" class="headerlink" title="•  两大核心作用    转发和路由"></a>•  两大核心作用    转发和路由</h3><h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>​                将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地操作</p><p>​                路由器将分组移动到合适的输出链路，每个路由均有<strong>转发表</strong>，存储对应首部和其输出</p><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>​                确定分组从源到目的地所采取的端到端路径的网络范围处理过程，选择从发送方到接收方的路径</p><h3 id="•-Routing-路由器"><a href="#•-Routing-路由器" class="headerlink" title="•  Routing    路由器"></a>•  Routing    路由器</h3><h4 id="路由结构"><a href="#路由结构" class="headerlink" title="路由结构"></a>路由结构</h4><p>​        输入端口：通过查询转发表决定路由器的输出端口</p><p>​        交换结构：将路由器的输入端口连接到输出端口</p><p>​        输出端口：在输出链路上传输分组</p><p>​        路由选择处理器：执行控制平面功能，计算和维护转发表</p><h4 id="转发表"><a href="#转发表" class="headerlink" title="转发表"></a>转发表</h4><p>​        <strong>最长前缀匹配</strong>，相同前缀的一组目的地址分配到同一个输出接口</p><h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><p>​        经内存交换：产生中断，将分组复制到处理器内存与输出端口的缓存</p><p>​        经总线交换：经由一根共享总线将分组直接传送到输出端口</p><p>​        经互联网络交换：纵横式网络，能够并行转发多个分组</p><h4 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h4><p>​        输入排队：多个分组发往同一个输出端口，会产生阻塞且必须在其队列中等待（该队列中后续也无法发送），交换结构一次只能传送一个分组到指定端口</p><p>​        输出排队：当一个分组在输出链路中发送时，又有多个分组到达输出端口，输出端口阻塞，交换结构传输速率大于输出链路发送速率</p><h4 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h4><p>​        FIFO：先来先服务</p><p>​        优先级服务：按优先级大小选择最高优先权队列的分组发送</p><p>​        循环和加权公平排队</p><h3 id="•-IP-Internet-Protocol-网际协议"><a href="#•-IP-Internet-Protocol-网际协议" class="headerlink" title="•   IP      Internet Protocol      网际协议"></a>•   <strong>IP      Internet Protocol</strong>      <strong>网际协议</strong></h3><p>​    尽力而为交付服务，但不做任何的确保，<strong>不可靠</strong></p><h4 id="IPv4数据报首部"><a href="#IPv4数据报首部" class="headerlink" title="IPv4数据报首部"></a>IPv4数据报首部</h4><p>​            版本号：4比特，表示该IP数据报使用的IP协议版本，iPv4为4</p><p>​            首部长度：4比特，表示IP数据报的载荷，无选项的情况下为20字节</p><p>​            服务类型（TOS）：区别不同类型的IP数据报</p><p>​            数据报长度：16比特，表示整个IP数据报的长度（报头区+数据区）</p><p>​            <strong>标识、标志、片偏移</strong>：与IP分片有关</p><p>​            <strong>TTL</strong>——生存时间：数据报可以经过的最大路由器数，每经过一个处理它的路由器，值减1，当该字段为0时，数据报就丢弃</p><p>​            协议：承载的各种上层协议</p><p>​            <strong>首部检验和</strong>：检测收到的IP数据报的比特错误</p><p>​            源和目的IP地址：32位</p><h5 id="IP分片："><a href="#IP分片：" class="headerlink" title="IP分片："></a>IP分片：</h5><p>​            <strong>MTU</strong>——最大传送单元：一个链路层帧能承载的最大数据量</p><p>​            以太网承载量：1500字节</p><p>​            标识：将发送的每个数据报的标识加1</p><p>​            标志：最后一个片的标志为0，其余为1</p><p>​            片偏移：指定该片放在初始IP数据报的哪个位置</p><h4 id="ipv6数据报首部"><a href="#ipv6数据报首部" class="headerlink" title="ipv6数据报首部"></a>ipv6数据报首部</h4><p>​            版本号：4比特，表示该IP数据报使用的IP协议版本，ipv6为6</p><p>​            流量类型、有效载荷长度、下一个首部、跳限制（这些与iPv4对应字段差不多）</p><p>​            <strong>流标签</strong>：20比特，表示一条数据报的流，对来自某些应用的数据报给出更高的优先权</p><p>​            <strong>扩大容量的源和目的地址</strong>：128位</p><h3 id="•-CIDR-Classless-Inter-Domain-Routing-无类别域间路由选择"><a href="#•-CIDR-Classless-Inter-Domain-Routing-无类别域间路由选择" class="headerlink" title="•   CIDR    Classless Inter-Domain Routing    无类别域间路由选择"></a>•   CIDR    Classless Inter-Domain Routing    无类别域间路由选择</h3><p>​    IP地址以子网掩码的形式给出：<strong>a.b.c.d/x</strong></p><p>​    x位最高比特称为地址的前缀，一个子网下的主机拥有相同的前缀</p><p>​    分类编址：24位网络位（网络号）和8位主机位</p><p>​    对应分类编址（A、B、C类为可分配IP地址）：A类网络（/8）、B类网络（/16）、C类网络（/24）、广播地址（255.255.255.255）</p><h3 id="•-DHCP-Dynamic-Host-Configuration-Protocol-动态主机配置协议"><a href="#•-DHCP-Dynamic-Host-Configuration-Protocol-动态主机配置协议" class="headerlink" title="•   DHCP  Dynamic Host Configuration Protocol  动态主机配置协议"></a>•   <strong>DHCP  Dynamic Host Configuration Protocol</strong>  <strong>动态主机配置协议</strong></h3><p>​    为主机分配一个临时的IP地址</p><p>​    <strong>DHCP服务器发现</strong>：要找一个与其交互的DHCP服务器，发送<strong>DHCP发现报文</strong>（discover），向所有与该子网连接的节点<strong>广播</strong></p><p>​    <strong>DHCP服务器提供</strong>：DHCP服务器收到发现报文后，用<strong>DHCP提供报文</strong>（offer）向客户做出响应；DHCP提供报文包含可分配的IP地址、IP地址租用期等信息</p><p>​    <strong>DHCP请求</strong>：从一个或多个服务器中选择一个，发送包含对应IP地址的<strong>DHCP请求报文</strong>（request），此处目的地址仍使用广播地址，告知其他DHCP服务器自己已选定某个服务器</p><p>​    <strong>DHCP ACK</strong>：服务器最终响应</p><h3 id="•-NAT-Network-Address-Translation-网络地址转换"><a href="#•-NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="•   NAT    Network Address Translation 网络地址转换"></a>•   <strong>NAT    Network Address Translation</strong> <strong>网络地址转换</strong></h3><p>​    一个网络号仅在其子网范围内有意义（全世界相同的IP地址很多，公网上不可能使用）</p><p>​    使私有网络IP地址经过转换能在公共网络中使用，或将公共网络IP地址转化为私有网络的IP地址（在一个子网内部使用私有地址是可以的）</p><h4 id="NAT优点"><a href="#NAT优点" class="headerlink" title="NAT优点"></a>NAT优点</h4><p>​        只需从ISP申请一个IP地址即可；本地网络IP地址变更无须告知外界；变更ISP无需修改内网的IP；内网对外网不可见，安全</p><h4 id="NAT实现"><a href="#NAT实现" class="headerlink" title="NAT实现"></a>NAT实现</h4><p>​        替换：利用NAT的IP地址和端口号替换每个外出数据报的IP地址和端口号</p><p>​        记录：每对IP地址和端口号记录在<strong>NAT转换表</strong>中</p><p>​        替换：根据NAT转换表替换进入内网数据报的IP地址和端口号</p><h3 id="•-链路状态路由选择算法-LS-算法"><a href="#•-链路状态路由选择算法-LS-算法" class="headerlink" title="•   链路状态路由选择算法    LS 算法"></a>•   链路状态路由选择算法    LS 算法</h3><p>​    对每个节点构造从源节点沿着向它的最短路径上的前一个节点</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1</span>、初始化：<br>   N&#x27; = &#123;u&#125;                                                                                      <br>   <span class="hljs-keyword">for</span> all nodes <span class="hljs-keyword">for</span> n                                                                   <br>        <span class="hljs-keyword">if</span> n is a neighbor <span class="hljs-keyword">of</span> u                                                      <br>            <span class="hljs-keyword">then</span> <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> = c(u，n)                                                        <br>        <span class="hljs-keyword">else</span> <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> = ∞                                                                     <br><br><span class="hljs-number">2</span>、循环阶段<br>    find w not <span class="hljs-keyword">in</span> N&#x27; such that <span class="hljs-constructor">D(<span class="hljs-params">w</span>)</span> is a minimum     对于没有在节点子集上的点，找出前一次迭代结束后具有最低开销的点              <br>    add w <span class="hljs-keyword">to</span> N&#x27;                                                                            <br>    update <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> <span class="hljs-keyword">for</span> each neighbor n <span class="hljs-keyword">of</span> w <span class="hljs-keyword">and</span> not <span class="hljs-keyword">in</span> N&#x27;    更新最短消耗     <br>        <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span> = min( <span class="hljs-constructor">D(<span class="hljs-params">n</span>)</span>， <span class="hljs-constructor">D(<span class="hljs-params">w</span>)</span> + c(w，n) ）                              <br>    until N&#x27; = N                         节点全部遍历过   <br></code></pre></td></tr></table></figure><p>​                                                </p><h3 id="•-距离向量路由选择算法-DV-算法"><a href="#•-距离向量路由选择算法-DV-算法" class="headerlink" title="•   距离向量路由选择算法    DV 算法"></a>•   距离向量路由选择算法    DV 算法</h3><script type="math/tex; mode=display">d_x(y) = min_v[c(x,v) + d_v(y)]</script><p>​    c表示从结点x到邻接结点v的费用，d表示从邻接结点v到目的结点y的最小费用路径的费用</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs llvm">对每个结点<span class="hljs-keyword">x</span>进行如下操作：<br>    初始化：<br>        遍历所有网络中的所有目的地y：<br>            初始化为邻接节点的距离，如果是非邻接结点，那么距离为∞。<br>        遍历每个邻接结点 w：<br>            初始化邻接结点 w 的距离向量<br>        遍历每个邻接结点 w:  <br>            发送本结点 <span class="hljs-keyword">x</span> 的距离向量到每个邻接结点 w。<br><br>​    循环：<br>​        等待（知道存在链路状态变化或者收到其他结点的距离向量之后终止等待）<br>​        遍历网络 N 中的每个结点 y：<br>​            依照bellman-ford方程更新本地 <span class="hljs-keyword">x</span> 距离向量<br>​        如果 <span class="hljs-keyword">x</span> 的距离向量存在变化<br>​            发送 <span class="hljs-keyword">x</span> 的距离向量给每一个邻居结点<br></code></pre></td></tr></table></figure><h3 id="•-OSPF-Open-Shortest-Path-First-开放式最短路径优先"><a href="#•-OSPF-Open-Shortest-Path-First-开放式最短路径优先" class="headerlink" title="•   OSPF   Open Shortest Path First  开放式最短路径优先"></a>•   <strong>OSPF   Open Shortest Path First</strong>  <strong>开放式最短路径优先</strong></h3><p>​    <strong>自治系统AS</strong>：由一组通常处在相同管理控制下的路由器组成</p><p>​    OSFP是一个链路状态协议，<strong>是自治系统AS内部的路由选择协议</strong></p><h4 id="OFPF工作实现"><a href="#OFPF工作实现" class="headerlink" title="OFPF工作实现"></a>OFPF工作实现</h4><p>​        每个路由器按照LS算法获知自己到所在AS内其他路由器的最短路径</p><p>​        使用OSFP时，路由器向AS内的所有其他路由器广播路由选择信息</p><p>​        当一条链路状态发生改变时，路由器就会广播链路状态信息；即使没有改变，路由器也会周期性的广播链路状态信息</p><h4 id="OSPF特点"><a href="#OSPF特点" class="headerlink" title="OSPF特点"></a>OSPF特点</h4><p>​        安全：仅由受信任的路由器能参与一个AS内的OSPF协议，所有OSPF报文在认证之后才能使用</p><p>​        多条相同开销的路径：可以均衡负载，分散数据</p><p>​        对单播与多播路由选择的综合支持</p><p>​        <strong>支持单个AS内的层次结构</strong>：OSPF最大优点</p><p>​                一个AS由一个主干区和多个局部区组成：主干由区边界路由器、主干路由器（计算路由）和AS边界路由器（连接其他AS）构成</p><p>​                区边界路由器：汇总到达所在区的距离，并告知其他区边界路由器</p><p>​                链路通告仅限于区内，每个路由器掌握所在AS的详细拓扑，但不知道其他区的信息</p><p>​                </p><p><img src="/images/cs_net/QQ截图20210622173442.png" style="zoom: 67%;"></p><h3 id="•-BGP-Border-Gateway-Protocol-边界网关协议"><a href="#•-BGP-Border-Gateway-Protocol-边界网关协议" class="headerlink" title="•   BGP  Border Gateway Protocol  边界网关协议"></a>•   <strong>BGP  Border Gateway Protocol</strong>  <strong>边界网关协议</strong></h3><p>​    <strong>ISP之间的路由选择协议</strong></p><h4 id="BGP作用："><a href="#BGP作用：" class="headerlink" title="BGP作用："></a>BGP作用：</h4><p>​        从邻居AS获得前缀的可达性信息：允许每个子网向其他子网通告信息</p><p>​        确定到该前缀的最好路由</p><h4 id="BGP连接："><a href="#BGP连接：" class="headerlink" title="BGP连接："></a>BGP连接：</h4><p>​        eBGP：外部BGP，跨越两个AS之间的连接，从邻居AS获取可达性信息</p><p>​        iBGP：内部BGP，相同AS的两台路由器之间的连接，向所有AS内部路由器传递可达性信息</p><h4 id="BGP属性："><a href="#BGP属性：" class="headerlink" title="BGP属性："></a>BGP属性：</h4><p>​        AS-PATH：已经通过的AS列表</p><p>​        NEXT-HOP：AS-PATH起始路由器接口的IP地址，两个AS之间互相连接的边界路由器的接口IP地址</p><p>​        eg：AS2 AS3 x 表示AS3中的x路由器的路径</p><p><img src="/images/cs_net/QQ截图20210622191007.png" alt></p><h4 id="BGP的路由选择："><a href="#BGP的路由选择：" class="headerlink" title="BGP的路由选择："></a>BGP的路由选择：</h4><p>​        热土豆算法：只关注当前能到的具有最小开销的路径，而不管之后的路径开销</p><p>​        路由器选择算法：若路由被指派了一个本地偏好，则选择具有最高本地偏好值的路由；若本地偏好值相同，则选择具有最短AS-PATH的路由；若两者都相同，则选择最靠近NEXT-HOP的路由</p><h3 id="•-ICMP-Internet-Control-Message-Protocol-因特网控制报文协议"><a href="#•-ICMP-Internet-Control-Message-Protocol-因特网控制报文协议" class="headerlink" title="•   ICMP   Internet Control Message Protocol  因特网控制报文协议"></a>•   <strong>ICMP   Internet Control Message Protocol</strong>  <strong>因特网控制报文协议</strong></h3><p>​    差错报告（返回错误报文）、网络探询</p><p>​    承载在IP分组中，作为IP的有效载荷</p><h4 id="ICMP报文构成："><a href="#ICMP报文构成：" class="headerlink" title="ICMP报文构成："></a>ICMP报文构成：</h4><p>​            一个<strong>类型字段</strong>、一个<strong>编码字段</strong>，并且包含首次生成的IP数据报的首部和前8个字节，包括源和目的IP地址，源和目的端口号等</p><p><img src="/images/cs_net/QQ截图20210622191741.png" style="zoom: 80%;"></p><h4 id="差错报告发送情况："><a href="#差错报告发送情况：" class="headerlink" title="差错报告发送情况："></a>差错报告发送情况：</h4><p>​            产生错误报文时发送ICMP差错报告，eg：TTL超期（减到0），路由器丢弃数据报并发送ICMP告警报文</p><p>​            若IP数据报被分片，只有第一个IP数据报分片发送差错报告，后续均不发送</p><p>​            多播IP数据报均不发送差错报告</p><p>​            特殊地址（如127.0.0.0）不发送差错报告</p><h3 id="•-SNMP-Simple-Network-Management-Protocol-简单网络管理协议"><a href="#•-SNMP-Simple-Network-Management-Protocol-简单网络管理协议" class="headerlink" title="•   SNMP   Simple Network Management Protocol  简单网络管理协议"></a><strong>•   SNMP   Simple Network Management Protocol  简单网络管理协议</strong></h3><p>​    用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文</p><h4 id="网络管理的组件："><a href="#网络管理的组件：" class="headerlink" title="网络管理的组件："></a>网络管理的组件：</h4><p>​            管理服务器：应用程序，控制网络管理信息的收集、处理、分析和显示，发起控制网络行为的动作</p><p>​            被管设备：有多个被管对象构成</p><p>​            管理信息库（MIB）：收集一个被管设备中每个被管对象的关联信息</p><p>​            网络管理代理：驻留在每个被管设备中，运行被管设备中的一个进程，该进程与管理服务器通信</p><p>​            网络管理协议：允许管理服务器查询被管设备的状态，并经过代理间接地在这些设备上采取行动</p><p><img src="/images/cs_net/QQ图片20210622193305.jpg" style="zoom: 50%;"></p><h4 id="SNMP报文——PDU（协议数据单元）"><a href="#SNMP报文——PDU（协议数据单元）" class="headerlink" title="SNMP报文——PDU（协议数据单元）"></a>SNMP报文——PDU（协议数据单元）</h4><p>​            请求响应模式：向SNMP代理发送一个请求，代理收到后执行某些动作</p><p>​            陷阱报文：通知管理服务器产生了一个异常，导致了MIB对象值的改变</p><p><img src="/images/cs_net/QQ图片20210622194810.jpg" style="zoom:50%;"></p><h3 id="•-SDN-Software-Defined-Network-软件定义网络"><a href="#•-SDN-Software-Defined-Network-软件定义网络" class="headerlink" title="•  SDN    Software Defined Network    软件定义网络"></a>•  SDN    Software Defined Network    软件定义网络</h3><p>​    使用openflow协议</p><h4 id="SDN体系结构的特征："><a href="#SDN体系结构的特征：" class="headerlink" title="SDN体系结构的特征："></a>SDN体系结构的特征：</h4><p>​            基于流的转发：能够基于运输层、网络层或链路层首部中的任意数量的首部字段值进行转发（传统IP数据报只能依据目的IP进行）</p><p>​            <strong>数据平面和控制平面分离</strong>：数据平面——<strong>网络交换机</strong>组成，在其流表中执行匹配加动作；控制平面——服务器和控制管理交换机流表的软件</p><p>​            网络控制功能：控制平面构成——<strong>SDN控制器</strong>和若干<strong>网络控制程序</strong></p><p>​            可编程的网络</p><p><img src="/images/cs_net/QQ截图20210622154127.png" style="zoom:50%;"></p><h4 id="SDN控制平面的3层次："><a href="#SDN控制平面的3层次：" class="headerlink" title="SDN控制平面的3层次："></a>SDN控制平面的3层次：</h4><p>​            通信层：SDN控制器和受控网络设备之间的通信</p><p>​            网络范围状态管理层：SDN最终的控制决定（如配置所有交换机的流表以取得端到端的转发、实现负载均衡等），需要控制器具有有关网络的最新状态信息</p><p>​            对于网络控制应用的程序层的接口：允许网络控制应用程序在状态管理层之间读写网络状态和流表</p><p><img src="/images/cs_net/QQ图片20210622152430.jpg" style="zoom: 33%;"></p><p>​    通过远程控制器计算和分发转发表，以共每台路由器（在SDN中称作<strong>分组交换机</strong>）使用</p><p>​    交换机的行为：匹配加动作——匹配：查找IP地址；动作：将分组发送到有特定输出端口的交换结构</p><p>​    openflow——<strong>流表</strong></p><p>​            首部字段值的集合：</p><p>​            计数器集合：包括已经与该表相匹配的分组数量，以及自从该表上次更新以来的时间</p><p>​            当分组到达流表时所采取的动作的集合：包括转发到指定输出端口、丢弃该分组、复制该分组、发送到多个输出端口、重写首部字段</p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a><strong>链路层</strong></h1><p><strong>负责通过一个链路从一个节点向另一个物理链路直接相邻的节点传递数据帧</strong></p><p>运行任何链路层协议的设备称为<strong>节点</strong>，通信路径连接相邻节点的通信信道称为<strong>链路</strong></p><h2 id="•-链路层提供的服务"><a href="#•-链路层提供的服务" class="headerlink" title="•  链路层提供的服务"></a>•  链路层提供的服务</h2><p>​    <strong>成帧</strong>：几乎所有的链路成协议都要将链路层帧封装起来，一个帧有一个数据字段和若干首部字段组成</p><p>​    <strong>链路接入</strong>：媒体访问控制协议（MAC）规定了链路传输规则，MAC地址标识帧的源和目的</p><p>​    <strong>可靠交付</strong>：通常用于易产生高差错率的链路（无线网络），保证无差错的经链路层移动每个网络层数据报，在低差错率的链路上较少使用（光纤、同轴电缆等）</p><p>​    <strong>差错纠正和检测</strong>：差错检测通常使用硬件实现，差错纠正能准确确定帧中出错的位置并纠正</p><p>​    <strong>全双工与半双工</strong>：全双工——两端点同时双向传输；半双工——两端点交替双向传输</p><h3 id="•-差错检测与纠正技术："><a href="#•-差错检测与纠正技术：" class="headerlink" title="•  差错检测与纠正技术："></a>•  差错检测与纠正技术：</h3><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>​            单个奇偶校验：在数据末端增加1位奇偶校验位，选择它的值使得这d+1个比特中1的总数为偶数个则为偶校验（奇数个则为奇校验），比较两者是否同奇或同偶</p><p>​            二位奇偶校验：对每行每列计算奇偶值，产生的i+j+1奇偶比特构成了链路层帧的差错检测比特，并且能根据行和列的索引定位差错比特并纠正</p><p><img src="/images/cs_net/QQ图片20210622202233.jpg" style="zoom: 50%;"></p><h4 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h4><p>​            d比特数据看作多个k比特的整数的序列，对其求和，这个和的<strong>反码</strong>作为校验和，当接收方将其接受到的数据的和跟校验和相加，如果结果有一个比特不为1，说明出现了比特错误</p><h4 id="循环冗余检测CRC"><a href="#循环冗余检测CRC" class="headerlink" title="循环冗余检测CRC"></a>循环冗余检测CRC</h4><p>​            d比特的数据D，发送节点要将其发送给接收节点，它们之间必须协商一个r+1比特模式，我们将其表示为G,我们将要求G的最高位有效比特是1，且一个d比特的数据加上一个r比特的R,得到的d+r比特模式用摸2除法恰好能被G整除</p><p>​            CRC进行差错检测的原理：接收方用G去除接收到的d+r比特，如果余数为非零，则表示数据出错了</p><p><img src="/images/cs_net/QQ图片20210622203926.jpg" style="zoom:50%;"></p><h3 id="•-MAC-Multiple-Access-Control-Protocol-多路访问控制"><a href="#•-MAC-Multiple-Access-Control-Protocol-多路访问控制" class="headerlink" title="•   MAC   Multiple Access Control Protocol   多路访问控制"></a>•   <strong>MAC   Multiple Access Control Protocol   </strong>多路访问控制</h3><h4 id="信道划分协议："><a href="#信道划分协议：" class="headerlink" title="信道划分协议："></a>信道划分协议：</h4><p>​            <strong>不会产生冲突</strong>，适用于网络负载较重的情况，网络负载较轻会产生资源浪费</p><p>​            <strong>时分复用TDM</strong>：将时间划分为时间帧，并将每个时间帧为 N 个时隙，把每个时隙分给 N 个节点中的一个</p><p>​            <strong>频分复用FDM</strong>：将 R bps的信道划分为不同的频段，每个频段 R/N 的带宽，并把每个频率分给 N 个节点中的一个</p><p>​            <strong>码分多址CDMA</strong>：为每个节点分配一种不同的编码，每个节点用唯一的编码对发送的数据进行编码，能支持不同节点同时传输</p><h4 id="随机接入协议："><a href="#随机接入协议：" class="headerlink" title="随机接入协议："></a>随机接入协议：</h4><p>​            没有实现的节点协调，<strong>会冲突</strong>——检测冲突或从冲突中恢复</p><p>​            随机体现在——<strong>碰撞的节点在等待一个随机时延后重发帧</strong></p><p>​            <strong>时隙ALOHA</strong>：时间被划分成等长的时隙，一个时隙对应传输一帧的时间，节点只在时隙起点传输帧，若有碰撞则以概率p在后续的每个时隙里发送帧，最大效率为0.37</p><p><img src="/images/cs_net/QQ截图20210622214410.png" style="zoom:50%;"></p><p><img src="/images/cs_net/QQ截图20210622214530.png" style="zoom: 67%;"></p><p>​            <strong>ALOHA</strong>：不对时间进行划分，可以在任何时间发送，因此冲突率增大，避损时区为[t0 -1 ,t0+1]，仍以概率p重传该帧</p><p>​            纯ALOHA的效率要低于时隙ALOHA</p><p><img src="/images/cs_net/QQ截图20210622214814.png" style="zoom:67%;"></p><p>​            <strong>CSMA  Carrier Sense Multiple Access  载波侦听多路访问</strong>：侦听信号是否空闲，空闲时发送帧</p><p>​            <strong>CSMA / CD  Carrier Sense Multiple Access with Collision Detection    具有碰撞检测的载波侦听多路访问</strong></p><p>​                    监听到信道空闲才会发送帧，否则等待直到侦听没有信号能量时才开始传输帧</p><p>​                    边发送帧边检测冲突，若检测到其它信号，终止传输</p><h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><p>​            轮询协议：<strong>主节点</strong>以循环的方式轮询每个节点，告诉该节点能够传输的真的最大数量</p><p>​            令牌传递协议：以<strong>令牌</strong>的特殊帧在节点之间交换，当一个节点收到令牌时，仅当它有帧要发送时才持有令牌，否则传递给下一个节点</p><h3 id="•-ARP-Address-Resolution-Protocol-地址解析协议"><a href="#•-ARP-Address-Resolution-Protocol-地址解析协议" class="headerlink" title="•   ARP    Address Resolution Protocol  地址解析协议"></a>•   <strong>ARP    Address Resolution Protocol</strong>  <strong>地址解析协议</strong></h3><p>​    MAC 地址：标识一个帧从哪个接口发出到达哪个物理相连的其他接口</p><p>​    MAC地址和IP地址的区别：MAC可携带，可从一个局域网转移到另一个局域网，MAC地址唯一；IP地址不可携带，依赖于节点连接的子网，不唯一    </p><p>​    <strong>ARP作用</strong>：网络层IP地址和链路层地址MAC地址的转换，<strong>解析IP地址至MAC地址，获取某某IP主机的MAC地址</strong></p><p>​    <strong>ARP只能解析在同一个子网上的主机和路由器接口的IP地址</strong></p><h4 id="ARP实现"><a href="#ARP实现" class="headerlink" title="ARP实现"></a><strong>ARP实现</strong></h4><p>​        每台主机或路由器在其内存中具有一个<strong>ARP表</strong>，包含了<strong>IP地址到MAC地址</strong>的映射，以及一个TTL（超时会将该映射丢弃）</p><p>​        子网内发送：发送方构造一个ARP分组，包含发送和接收IP地址与MAC地址</p><p>​                                源主机广播ARP查询分组，以广播地址作为目的MAC地址，子网上的每个适配器收到该帧，检查自身IP是否与目的IP地址相同，若相同则返回一个响应的ARP分组，使源主机更新其ARP表</p><p>​        向子网外发送数据：子网A构造IP数据报，封装帧，并发送到路由器，其目的MAC地址为路由器R的左接口MAC地址</p><p>​                                        子网A成功发送帧，路由器接收帧并提取、解析IP数据报传输至上层IP（其间可进行NAT转换），获取目的MAC地址或者下一跳的地址（通过ARP解析得到）</p><p>​                                        R转发IP数据报（源和目的IP地址不变），封装帧，由R的右接口MAC发送至目的主机</p><p>​        当两台主机处在一个子网下，发送IP数据报不需要经由路由器转发</p><p>​        当两台主机处在一个子网下，可以通过ARP查询报文获取对方的MAC地址；不在一个子网下，无法通过ARP查询获得MAC地址</p><h3 id="•-Ethernet-以太网"><a href="#•-Ethernet-以太网" class="headerlink" title="•  Ethernet    以太网"></a>•  Ethernet    以太网</h3><h4 id="以太网数据报："><a href="#以太网数据报：" class="headerlink" title="以太网数据报："></a>以太网数据报：</h4><p>​            数据字段：承载了IP数据报，以太网的MTU是1500字节</p><p>​            目的地址：包含目的适配器的MAC地址</p><p>​            源地址：传输该帧到链路上的MAC地址</p><p>​            CRC：检测是否产生差错</p><p>​            前同步码：前7个字节的值均为10101010；最后一个字节为10101011，保证发送端与接收端的时钟同步</p><h4 id="以太网特点："><a href="#以太网特点：" class="headerlink" title="以太网特点："></a>以太网特点：</h4><p>​            无确认、无连接、不可靠</p><p>​            使用链路层协议：CSMA/CD</p><h3 id="•-链路层交换机"><a href="#•-链路层交换机" class="headerlink" title="•  链路层交换机"></a>•  链路层交换机</h3><p>​    交换机的过滤和转发借助于<strong>交换机表</strong></p><h4 id="交换机表内容："><a href="#交换机表内容：" class="headerlink" title="交换机表内容："></a>交换机表内容：</h4><p>​            一个MAC地址、通向该MAC地址的交换机接口、表项放置在表中的时间</p><h4 id="交换机工作过程："><a href="#交换机工作过程：" class="headerlink" title="交换机工作过程："></a>交换机工作过程：</h4><p>​            目的MAC地址从交换机的接口x到达：</p><p>​            若表中没有该MAC地址的表项，则交换机向除接口x以外的所有接口广播该帧</p><p>​            若该MAC地址有一个与 x 相连的表项，无需将该帧转发至其他接口（本来就属于x），交换机丢弃该帧</p><p>​            若该MAC地址有一个与其他接口 y 相连的表项，则该帧被转发到与 y 相连的局域网内</p><h4 id="自学习："><a href="#自学习：" class="headerlink" title="自学习："></a>自学习：</h4><p>​            可以获知到达主机的接口信息</p><p>​            交换机表初始为空，对于每个接口收到的每个入帧，在表中存储：源地址字段中的MAC地址、该帧到达的接口、当前时间</p><p>​            如果在一段时间内交换机没有收到以该地址作为源地址的帧，则删除该表项</p><h4 id="交换机与路由器的比较："><a href="#交换机与路由器的比较：" class="headerlink" title="交换机与路由器的比较："></a>交换机与路由器的比较：</h4><p>​        相同：均为存储-转发设备，均使用转发表</p><p>​        相异：交换机是链路层设备，路由器是网络层设备；交换机通过自学习更新转发表，路由器通过路由算法更新转发表；交换机即插即用，无需配置，路由器并非即插即用，需要人为配置IP地址</p><h3 id="•-无线链路"><a href="#•-无线链路" class="headerlink" title="•   无线链路"></a>•   无线链路</h3><h4 id="无线与有线的区别："><a href="#无线与有线的区别：" class="headerlink" title="无线与有线的区别："></a>无线与有线的区别：</h4><p>​            递减的信号强度：电磁波有损，信号强度随着距离的的增加而减弱</p><p>​            来自其他源的干扰：同一个频段的电磁波会互相干扰</p><p>​            多径传播：经过反射和折射变为多径，使接收到的信号变模糊</p><p>​    <strong>信噪比 SNR</strong>：所收到的信号和噪声强度的相对值</p><p>​    <strong>比特差错率 BER</strong>：接收方收到有错比特的概率</p><p>​            对于给定的方案，SNR越高，BER越低——增加传输速率降低错帧概率</p><p>​            对于给定的SNR，具有较高比特传输率的调制技术将有较高的BER</p><h4 id="隐藏终端问题："><a href="#隐藏终端问题：" class="headerlink" title="隐藏终端问题："></a>隐藏终端问题：</h4><p>​            两台主机之间存在物体阻挡，或无线媒体传播时信号强度衰减过多，以至于不足以检测到对方的传输</p><h5 id="CDMA码分多址："><a href="#CDMA码分多址：" class="headerlink" title="CDMA码分多址："></a>CDMA码分多址：</h5><p><img src="/images/cs_net/QQ图片20210623100815.jpg" style="zoom:50%;"></p><p>​            </p><h3 id="•-无线网络-802-11——WiFi"><a href="#•-无线网络-802-11——WiFi" class="headerlink" title="•   无线网络    802.11——WiFi"></a>•   无线网络    802.11——WiFi</h3><p>​    基本结构：<strong>基本服务集 BSS</strong>：一个BSS 包含一个或多个无线站点和一个AP中央基站</p><p><img src="/images/cs_net/QQ图片20210623100823.jpg" style="zoom:50%;"></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>​        AP设置：一个单字或双字的服务集标识符SSID，分配一个信道号</p><p>​        无线站点的加入：加入其中一个子网并与其中一个AP相关联（相当于提供用户名和密码）</p><p>​        802.11要求每个AP周期性的发送信标帧</p><h4 id="被动扫描与主动扫描"><a href="#被动扫描与主动扫描" class="headerlink" title="被动扫描与主动扫描"></a>被动扫描与主动扫描</h4><p>​        被动扫描：扫描信道和监听信标帧的过程</p><p>​        主动扫描：向位于无线主机范围内的所有AP广播探测帧</p><p><img src="/images/cs_net/QQ图片20210623100820.jpg" style="zoom: 50%;"></p><h4 id="802-11的MAC协议：CSMA-CA"><a href="#802-11的MAC协议：CSMA-CA" class="headerlink" title="802.11的MAC协议：CSMA/CA"></a>802.11的MAC协议：CSMA/CA</h4><p>​        核心：避免碰撞而不是检测碰撞</p><p>​        当某站点最初监听到信道空闲，会在一个DIFS（分布式帧间间隔）的短时间后发送该帧</p><p>​        否则选取一个随机回退值，在信道空闲时递减该值，当值为0时发送整个数据帧并等待确认</p><p>​        若收到确认则表明成功发送；若未收到重新回退，在更大的随机范围内选取一个回退值</p><p>​        为何不用CSMA/CD：<strong>无线网络的衰减很严重，在无线网络中难以检测到冲突；而以太网为有线链路，冲突反应强度大衰减小，易于检测</strong></p><p>​        链路层的确认方法：通过CRC校验后，等待一个SIFS时间（短帧间间隔）发回一个确认帧</p><h4 id="隐藏终端处理"><a href="#隐藏终端处理" class="headerlink" title="隐藏终端处理"></a>隐藏终端处理</h4><p>​        使用一个短请求发送（RTS）和一个短允许发送（CTS）来<strong>预约</strong>信道的访问，数据只有在预约后才能传输</p><p>​        发送方先发送一个RTS帧，指示传输帧和确认帧所需的总时间</p><p>​        AP收到RTS帧后广播一个CTS帧：给发送方明确的发送许可、指示其他站点在预约期内不要发送</p><p><img src="/images/cs_net/QQ图片20210623102329.jpg" style="zoom:50%;"></p><h4 id="802-11-帧结构"><a href="#802-11-帧结构" class="headerlink" title="802.11 帧结构"></a>802.11 帧结构</h4><p><img src="/images/cs_net/QQ图片20210623102614.jpg" style="zoom:50%;"></p><p>​        有效载荷：通常由IP数据报或者ARP分组构成</p><p>​        地址1：要接收该帧的无线站点的MAC地址</p><p>​        地址2：传输该帧的站点的MAC地址</p><p>​        地址3：第一跳的MAC地址</p>]]></content>
    
    
    <categories>
      
      <category>cs learning</category>
      
      <category>computer networks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer networks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/08/hello-world/"/>
    <url>/2022/03/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
